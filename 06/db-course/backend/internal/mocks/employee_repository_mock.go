package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/ports.EmployeeRepository -o ./internal/mocks/employee_repository_mock.go -n EmployeeRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// EmployeeRepositoryMock implements ports.EmployeeRepository
type EmployeeRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, emp models.Employee) (ep1 *models.Employee, err error)
	inspectFuncCreate   func(ctx context.Context, emp models.Employee)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mEmployeeRepositoryMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mEmployeeRepositoryMockDelete

	funcGetAll          func(ctx context.Context) (ea1 []models.Employee, err error)
	inspectFuncGetAll   func(ctx context.Context)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mEmployeeRepositoryMockGetAll

	funcGetByCredentials          func(ctx context.Context, nickname string, password string) (ep1 *models.Employee, err error)
	inspectFuncGetByCredentials   func(ctx context.Context, nickname string, password string)
	afterGetByCredentialsCounter  uint64
	beforeGetByCredentialsCounter uint64
	GetByCredentialsMock          mEmployeeRepositoryMockGetByCredentials

	funcGetByDepartment          func(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error)
	inspectFuncGetByDepartment   func(ctx context.Context, id uuid.UUID)
	afterGetByDepartmentCounter  uint64
	beforeGetByDepartmentCounter uint64
	GetByDepartmentMock          mEmployeeRepositoryMockGetByDepartment

	funcGetByID          func(ctx context.Context, id uuid.UUID) (ep1 *models.Employee, err error)
	inspectFuncGetByID   func(ctx context.Context, id uuid.UUID)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mEmployeeRepositoryMockGetByID

	funcGetByNickname          func(ctx context.Context, nickname string) (ep1 *models.Employee, err error)
	inspectFuncGetByNickname   func(ctx context.Context, nickname string)
	afterGetByNicknameCounter  uint64
	beforeGetByNicknameCounter uint64
	GetByNicknameMock          mEmployeeRepositoryMockGetByNickname

	funcGetByTeam          func(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error)
	inspectFuncGetByTeam   func(ctx context.Context, id uuid.UUID)
	afterGetByTeamCounter  uint64
	beforeGetByTeamCounter uint64
	GetByTeamMock          mEmployeeRepositoryMockGetByTeam

	funcListSimilarByName          func(ctx context.Context, substr string) (ea1 []models.Employee, err error)
	inspectFuncListSimilarByName   func(ctx context.Context, substr string)
	afterListSimilarByNameCounter  uint64
	beforeListSimilarByNameCounter uint64
	ListSimilarByNameMock          mEmployeeRepositoryMockListSimilarByName

	funcListSimilarByNickname          func(ctx context.Context, substr string) (ea1 []models.Employee, err error)
	inspectFuncListSimilarByNickname   func(ctx context.Context, substr string)
	afterListSimilarByNicknameCounter  uint64
	beforeListSimilarByNicknameCounter uint64
	ListSimilarByNicknameMock          mEmployeeRepositoryMockListSimilarByNickname

	funcSoftDelete          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncSoftDelete   func(ctx context.Context, id uuid.UUID)
	afterSoftDeleteCounter  uint64
	beforeSoftDeleteCounter uint64
	SoftDeleteMock          mEmployeeRepositoryMockSoftDelete

	funcUpdate          func(ctx context.Context, emp models.Employee) (err error)
	inspectFuncUpdate   func(ctx context.Context, emp models.Employee)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mEmployeeRepositoryMockUpdate
}

// NewEmployeeRepositoryMock returns a mock for ports.EmployeeRepository
func NewEmployeeRepositoryMock(t minimock.Tester) *EmployeeRepositoryMock {
	m := &EmployeeRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mEmployeeRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*EmployeeRepositoryMockCreateParams{}

	m.DeleteMock = mEmployeeRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*EmployeeRepositoryMockDeleteParams{}

	m.GetAllMock = mEmployeeRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*EmployeeRepositoryMockGetAllParams{}

	m.GetByCredentialsMock = mEmployeeRepositoryMockGetByCredentials{mock: m}
	m.GetByCredentialsMock.callArgs = []*EmployeeRepositoryMockGetByCredentialsParams{}

	m.GetByDepartmentMock = mEmployeeRepositoryMockGetByDepartment{mock: m}
	m.GetByDepartmentMock.callArgs = []*EmployeeRepositoryMockGetByDepartmentParams{}

	m.GetByIDMock = mEmployeeRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*EmployeeRepositoryMockGetByIDParams{}

	m.GetByNicknameMock = mEmployeeRepositoryMockGetByNickname{mock: m}
	m.GetByNicknameMock.callArgs = []*EmployeeRepositoryMockGetByNicknameParams{}

	m.GetByTeamMock = mEmployeeRepositoryMockGetByTeam{mock: m}
	m.GetByTeamMock.callArgs = []*EmployeeRepositoryMockGetByTeamParams{}

	m.ListSimilarByNameMock = mEmployeeRepositoryMockListSimilarByName{mock: m}
	m.ListSimilarByNameMock.callArgs = []*EmployeeRepositoryMockListSimilarByNameParams{}

	m.ListSimilarByNicknameMock = mEmployeeRepositoryMockListSimilarByNickname{mock: m}
	m.ListSimilarByNicknameMock.callArgs = []*EmployeeRepositoryMockListSimilarByNicknameParams{}

	m.SoftDeleteMock = mEmployeeRepositoryMockSoftDelete{mock: m}
	m.SoftDeleteMock.callArgs = []*EmployeeRepositoryMockSoftDeleteParams{}

	m.UpdateMock = mEmployeeRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*EmployeeRepositoryMockUpdateParams{}

	return m
}

type mEmployeeRepositoryMockCreate struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockCreateExpectation
	expectations       []*EmployeeRepositoryMockCreateExpectation

	callArgs []*EmployeeRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockCreateExpectation specifies expectation struct of the EmployeeRepository.Create
type EmployeeRepositoryMockCreateExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockCreateParams
	results *EmployeeRepositoryMockCreateResults
	Counter uint64
}

// EmployeeRepositoryMockCreateParams contains parameters of the EmployeeRepository.Create
type EmployeeRepositoryMockCreateParams struct {
	ctx context.Context
	emp models.Employee
}

// EmployeeRepositoryMockCreateResults contains results of the EmployeeRepository.Create
type EmployeeRepositoryMockCreateResults struct {
	ep1 *models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.Create
func (mmCreate *mEmployeeRepositoryMockCreate) Expect(ctx context.Context, emp models.Employee) *mEmployeeRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("EmployeeRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &EmployeeRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &EmployeeRepositoryMockCreateParams{ctx, emp}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.Create
func (mmCreate *mEmployeeRepositoryMockCreate) Inspect(f func(ctx context.Context, emp models.Employee)) *mEmployeeRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by EmployeeRepository.Create
func (mmCreate *mEmployeeRepositoryMockCreate) Return(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("EmployeeRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &EmployeeRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &EmployeeRepositoryMockCreateResults{ep1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the EmployeeRepository.Create method
func (mmCreate *mEmployeeRepositoryMockCreate) Set(f func(ctx context.Context, emp models.Employee) (ep1 *models.Employee, err error)) *EmployeeRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the EmployeeRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mEmployeeRepositoryMockCreate) When(ctx context.Context, emp models.Employee) *EmployeeRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("EmployeeRepositoryMock.Create mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &EmployeeRepositoryMockCreateParams{ctx, emp},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.Create return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockCreateExpectation) Then(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockCreateResults{ep1, err}
	return e.mock
}

// Create implements ports.EmployeeRepository
func (mmCreate *EmployeeRepositoryMock) Create(ctx context.Context, emp models.Employee) (ep1 *models.Employee, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, emp)
	}

	mm_params := &EmployeeRepositoryMockCreateParams{ctx, emp}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockCreateParams{ctx, emp}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("EmployeeRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the EmployeeRepositoryMock.Create")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, emp)
	}
	mmCreate.t.Fatalf("Unexpected call to EmployeeRepositoryMock.Create. %v %v", ctx, emp)
	return
}

// CreateAfterCounter returns a count of finished EmployeeRepositoryMock.Create invocations
func (mmCreate *EmployeeRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of EmployeeRepositoryMock.Create invocations
func (mmCreate *EmployeeRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mEmployeeRepositoryMockCreate) Calls() []*EmployeeRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.Create")
	}
}

type mEmployeeRepositoryMockDelete struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockDeleteExpectation
	expectations       []*EmployeeRepositoryMockDeleteExpectation

	callArgs []*EmployeeRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockDeleteExpectation specifies expectation struct of the EmployeeRepository.Delete
type EmployeeRepositoryMockDeleteExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockDeleteParams
	results *EmployeeRepositoryMockDeleteResults
	Counter uint64
}

// EmployeeRepositoryMockDeleteParams contains parameters of the EmployeeRepository.Delete
type EmployeeRepositoryMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EmployeeRepositoryMockDeleteResults contains results of the EmployeeRepository.Delete
type EmployeeRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for EmployeeRepository.Delete
func (mmDelete *mEmployeeRepositoryMockDelete) Expect(ctx context.Context, id uuid.UUID) *mEmployeeRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("EmployeeRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &EmployeeRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &EmployeeRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.Delete
func (mmDelete *mEmployeeRepositoryMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEmployeeRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by EmployeeRepository.Delete
func (mmDelete *mEmployeeRepositoryMockDelete) Return(err error) *EmployeeRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("EmployeeRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &EmployeeRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &EmployeeRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the EmployeeRepository.Delete method
func (mmDelete *mEmployeeRepositoryMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *EmployeeRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the EmployeeRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mEmployeeRepositoryMockDelete) When(ctx context.Context, id uuid.UUID) *EmployeeRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("EmployeeRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &EmployeeRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.Delete return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockDeleteExpectation) Then(err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements ports.EmployeeRepository
func (mmDelete *EmployeeRepositoryMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := &EmployeeRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("EmployeeRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the EmployeeRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to EmployeeRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished EmployeeRepositoryMock.Delete invocations
func (mmDelete *EmployeeRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of EmployeeRepositoryMock.Delete invocations
func (mmDelete *EmployeeRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mEmployeeRepositoryMockDelete) Calls() []*EmployeeRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.Delete")
	}
}

type mEmployeeRepositoryMockGetAll struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetAllExpectation
	expectations       []*EmployeeRepositoryMockGetAllExpectation

	callArgs []*EmployeeRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetAllExpectation specifies expectation struct of the EmployeeRepository.GetAll
type EmployeeRepositoryMockGetAllExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetAllParams
	results *EmployeeRepositoryMockGetAllResults
	Counter uint64
}

// EmployeeRepositoryMockGetAllParams contains parameters of the EmployeeRepository.GetAll
type EmployeeRepositoryMockGetAllParams struct {
	ctx context.Context
}

// EmployeeRepositoryMockGetAllResults contains results of the EmployeeRepository.GetAll
type EmployeeRepositoryMockGetAllResults struct {
	ea1 []models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetAll
func (mmGetAll *mEmployeeRepositoryMockGetAll) Expect(ctx context.Context) *mEmployeeRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("EmployeeRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &EmployeeRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &EmployeeRepositoryMockGetAllParams{ctx}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetAll
func (mmGetAll *mEmployeeRepositoryMockGetAll) Inspect(f func(ctx context.Context)) *mEmployeeRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by EmployeeRepository.GetAll
func (mmGetAll *mEmployeeRepositoryMockGetAll) Return(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("EmployeeRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &EmployeeRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &EmployeeRepositoryMockGetAllResults{ea1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the EmployeeRepository.GetAll method
func (mmGetAll *mEmployeeRepositoryMockGetAll) Set(f func(ctx context.Context) (ea1 []models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the EmployeeRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mEmployeeRepositoryMockGetAll) When(ctx context.Context) *EmployeeRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("EmployeeRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &EmployeeRepositoryMockGetAllParams{ctx},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetAllExpectation) Then(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetAllResults{ea1, err}
	return e.mock
}

// GetAll implements ports.EmployeeRepository
func (mmGetAll *EmployeeRepositoryMock) GetAll(ctx context.Context) (ea1 []models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx)
	}

	mm_params := &EmployeeRepositoryMockGetAllParams{ctx}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetAllParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("EmployeeRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the EmployeeRepositoryMock.GetAll")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx)
	}
	mmGetAll.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetAll. %v", ctx)
	return
}

// GetAllAfterCounter returns a count of finished EmployeeRepositoryMock.GetAll invocations
func (mmGetAll *EmployeeRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of EmployeeRepositoryMock.GetAll invocations
func (mmGetAll *EmployeeRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mEmployeeRepositoryMockGetAll) Calls() []*EmployeeRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetAll")
	}
}

type mEmployeeRepositoryMockGetByCredentials struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetByCredentialsExpectation
	expectations       []*EmployeeRepositoryMockGetByCredentialsExpectation

	callArgs []*EmployeeRepositoryMockGetByCredentialsParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetByCredentialsExpectation specifies expectation struct of the EmployeeRepository.GetByCredentials
type EmployeeRepositoryMockGetByCredentialsExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetByCredentialsParams
	results *EmployeeRepositoryMockGetByCredentialsResults
	Counter uint64
}

// EmployeeRepositoryMockGetByCredentialsParams contains parameters of the EmployeeRepository.GetByCredentials
type EmployeeRepositoryMockGetByCredentialsParams struct {
	ctx      context.Context
	nickname string
	password string
}

// EmployeeRepositoryMockGetByCredentialsResults contains results of the EmployeeRepository.GetByCredentials
type EmployeeRepositoryMockGetByCredentialsResults struct {
	ep1 *models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetByCredentials
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) Expect(ctx context.Context, nickname string, password string) *mEmployeeRepositoryMockGetByCredentials {
	if mmGetByCredentials.mock.funcGetByCredentials != nil {
		mmGetByCredentials.mock.t.Fatalf("EmployeeRepositoryMock.GetByCredentials mock is already set by Set")
	}

	if mmGetByCredentials.defaultExpectation == nil {
		mmGetByCredentials.defaultExpectation = &EmployeeRepositoryMockGetByCredentialsExpectation{}
	}

	mmGetByCredentials.defaultExpectation.params = &EmployeeRepositoryMockGetByCredentialsParams{ctx, nickname, password}
	for _, e := range mmGetByCredentials.expectations {
		if minimock.Equal(e.params, mmGetByCredentials.defaultExpectation.params) {
			mmGetByCredentials.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByCredentials.defaultExpectation.params)
		}
	}

	return mmGetByCredentials
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetByCredentials
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) Inspect(f func(ctx context.Context, nickname string, password string)) *mEmployeeRepositoryMockGetByCredentials {
	if mmGetByCredentials.mock.inspectFuncGetByCredentials != nil {
		mmGetByCredentials.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetByCredentials")
	}

	mmGetByCredentials.mock.inspectFuncGetByCredentials = f

	return mmGetByCredentials
}

// Return sets up results that will be returned by EmployeeRepository.GetByCredentials
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) Return(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetByCredentials.mock.funcGetByCredentials != nil {
		mmGetByCredentials.mock.t.Fatalf("EmployeeRepositoryMock.GetByCredentials mock is already set by Set")
	}

	if mmGetByCredentials.defaultExpectation == nil {
		mmGetByCredentials.defaultExpectation = &EmployeeRepositoryMockGetByCredentialsExpectation{mock: mmGetByCredentials.mock}
	}
	mmGetByCredentials.defaultExpectation.results = &EmployeeRepositoryMockGetByCredentialsResults{ep1, err}
	return mmGetByCredentials.mock
}

// Set uses given function f to mock the EmployeeRepository.GetByCredentials method
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) Set(f func(ctx context.Context, nickname string, password string) (ep1 *models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetByCredentials.defaultExpectation != nil {
		mmGetByCredentials.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetByCredentials method")
	}

	if len(mmGetByCredentials.expectations) > 0 {
		mmGetByCredentials.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetByCredentials method")
	}

	mmGetByCredentials.mock.funcGetByCredentials = f
	return mmGetByCredentials.mock
}

// When sets expectation for the EmployeeRepository.GetByCredentials which will trigger the result defined by the following
// Then helper
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) When(ctx context.Context, nickname string, password string) *EmployeeRepositoryMockGetByCredentialsExpectation {
	if mmGetByCredentials.mock.funcGetByCredentials != nil {
		mmGetByCredentials.mock.t.Fatalf("EmployeeRepositoryMock.GetByCredentials mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetByCredentialsExpectation{
		mock:   mmGetByCredentials.mock,
		params: &EmployeeRepositoryMockGetByCredentialsParams{ctx, nickname, password},
	}
	mmGetByCredentials.expectations = append(mmGetByCredentials.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetByCredentials return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetByCredentialsExpectation) Then(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetByCredentialsResults{ep1, err}
	return e.mock
}

// GetByCredentials implements ports.EmployeeRepository
func (mmGetByCredentials *EmployeeRepositoryMock) GetByCredentials(ctx context.Context, nickname string, password string) (ep1 *models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByCredentials.beforeGetByCredentialsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByCredentials.afterGetByCredentialsCounter, 1)

	if mmGetByCredentials.inspectFuncGetByCredentials != nil {
		mmGetByCredentials.inspectFuncGetByCredentials(ctx, nickname, password)
	}

	mm_params := &EmployeeRepositoryMockGetByCredentialsParams{ctx, nickname, password}

	// Record call args
	mmGetByCredentials.GetByCredentialsMock.mutex.Lock()
	mmGetByCredentials.GetByCredentialsMock.callArgs = append(mmGetByCredentials.GetByCredentialsMock.callArgs, mm_params)
	mmGetByCredentials.GetByCredentialsMock.mutex.Unlock()

	for _, e := range mmGetByCredentials.GetByCredentialsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmGetByCredentials.GetByCredentialsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByCredentials.GetByCredentialsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByCredentials.GetByCredentialsMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetByCredentialsParams{ctx, nickname, password}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByCredentials.t.Errorf("EmployeeRepositoryMock.GetByCredentials got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByCredentials.GetByCredentialsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByCredentials.t.Fatal("No results are set for the EmployeeRepositoryMock.GetByCredentials")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmGetByCredentials.funcGetByCredentials != nil {
		return mmGetByCredentials.funcGetByCredentials(ctx, nickname, password)
	}
	mmGetByCredentials.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetByCredentials. %v %v %v", ctx, nickname, password)
	return
}

// GetByCredentialsAfterCounter returns a count of finished EmployeeRepositoryMock.GetByCredentials invocations
func (mmGetByCredentials *EmployeeRepositoryMock) GetByCredentialsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCredentials.afterGetByCredentialsCounter)
}

// GetByCredentialsBeforeCounter returns a count of EmployeeRepositoryMock.GetByCredentials invocations
func (mmGetByCredentials *EmployeeRepositoryMock) GetByCredentialsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCredentials.beforeGetByCredentialsCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetByCredentials.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByCredentials *mEmployeeRepositoryMockGetByCredentials) Calls() []*EmployeeRepositoryMockGetByCredentialsParams {
	mmGetByCredentials.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetByCredentialsParams, len(mmGetByCredentials.callArgs))
	copy(argCopy, mmGetByCredentials.callArgs)

	mmGetByCredentials.mutex.RUnlock()

	return argCopy
}

// MinimockGetByCredentialsDone returns true if the count of the GetByCredentials invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetByCredentialsDone() bool {
	for _, e := range m.GetByCredentialsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByCredentialsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByCredentialsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByCredentials != nil && mm_atomic.LoadUint64(&m.afterGetByCredentialsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByCredentialsInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetByCredentialsInspect() {
	for _, e := range m.GetByCredentialsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByCredentials with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByCredentialsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByCredentialsCounter) < 1 {
		if m.GetByCredentialsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetByCredentials")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByCredentials with params: %#v", *m.GetByCredentialsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByCredentials != nil && mm_atomic.LoadUint64(&m.afterGetByCredentialsCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetByCredentials")
	}
}

type mEmployeeRepositoryMockGetByDepartment struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetByDepartmentExpectation
	expectations       []*EmployeeRepositoryMockGetByDepartmentExpectation

	callArgs []*EmployeeRepositoryMockGetByDepartmentParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetByDepartmentExpectation specifies expectation struct of the EmployeeRepository.GetByDepartment
type EmployeeRepositoryMockGetByDepartmentExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetByDepartmentParams
	results *EmployeeRepositoryMockGetByDepartmentResults
	Counter uint64
}

// EmployeeRepositoryMockGetByDepartmentParams contains parameters of the EmployeeRepository.GetByDepartment
type EmployeeRepositoryMockGetByDepartmentParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EmployeeRepositoryMockGetByDepartmentResults contains results of the EmployeeRepository.GetByDepartment
type EmployeeRepositoryMockGetByDepartmentResults struct {
	ea1 []models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetByDepartment
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) Expect(ctx context.Context, id uuid.UUID) *mEmployeeRepositoryMockGetByDepartment {
	if mmGetByDepartment.mock.funcGetByDepartment != nil {
		mmGetByDepartment.mock.t.Fatalf("EmployeeRepositoryMock.GetByDepartment mock is already set by Set")
	}

	if mmGetByDepartment.defaultExpectation == nil {
		mmGetByDepartment.defaultExpectation = &EmployeeRepositoryMockGetByDepartmentExpectation{}
	}

	mmGetByDepartment.defaultExpectation.params = &EmployeeRepositoryMockGetByDepartmentParams{ctx, id}
	for _, e := range mmGetByDepartment.expectations {
		if minimock.Equal(e.params, mmGetByDepartment.defaultExpectation.params) {
			mmGetByDepartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByDepartment.defaultExpectation.params)
		}
	}

	return mmGetByDepartment
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetByDepartment
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEmployeeRepositoryMockGetByDepartment {
	if mmGetByDepartment.mock.inspectFuncGetByDepartment != nil {
		mmGetByDepartment.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetByDepartment")
	}

	mmGetByDepartment.mock.inspectFuncGetByDepartment = f

	return mmGetByDepartment
}

// Return sets up results that will be returned by EmployeeRepository.GetByDepartment
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) Return(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetByDepartment.mock.funcGetByDepartment != nil {
		mmGetByDepartment.mock.t.Fatalf("EmployeeRepositoryMock.GetByDepartment mock is already set by Set")
	}

	if mmGetByDepartment.defaultExpectation == nil {
		mmGetByDepartment.defaultExpectation = &EmployeeRepositoryMockGetByDepartmentExpectation{mock: mmGetByDepartment.mock}
	}
	mmGetByDepartment.defaultExpectation.results = &EmployeeRepositoryMockGetByDepartmentResults{ea1, err}
	return mmGetByDepartment.mock
}

// Set uses given function f to mock the EmployeeRepository.GetByDepartment method
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) Set(f func(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetByDepartment.defaultExpectation != nil {
		mmGetByDepartment.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetByDepartment method")
	}

	if len(mmGetByDepartment.expectations) > 0 {
		mmGetByDepartment.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetByDepartment method")
	}

	mmGetByDepartment.mock.funcGetByDepartment = f
	return mmGetByDepartment.mock
}

// When sets expectation for the EmployeeRepository.GetByDepartment which will trigger the result defined by the following
// Then helper
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) When(ctx context.Context, id uuid.UUID) *EmployeeRepositoryMockGetByDepartmentExpectation {
	if mmGetByDepartment.mock.funcGetByDepartment != nil {
		mmGetByDepartment.mock.t.Fatalf("EmployeeRepositoryMock.GetByDepartment mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetByDepartmentExpectation{
		mock:   mmGetByDepartment.mock,
		params: &EmployeeRepositoryMockGetByDepartmentParams{ctx, id},
	}
	mmGetByDepartment.expectations = append(mmGetByDepartment.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetByDepartment return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetByDepartmentExpectation) Then(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetByDepartmentResults{ea1, err}
	return e.mock
}

// GetByDepartment implements ports.EmployeeRepository
func (mmGetByDepartment *EmployeeRepositoryMock) GetByDepartment(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByDepartment.beforeGetByDepartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByDepartment.afterGetByDepartmentCounter, 1)

	if mmGetByDepartment.inspectFuncGetByDepartment != nil {
		mmGetByDepartment.inspectFuncGetByDepartment(ctx, id)
	}

	mm_params := &EmployeeRepositoryMockGetByDepartmentParams{ctx, id}

	// Record call args
	mmGetByDepartment.GetByDepartmentMock.mutex.Lock()
	mmGetByDepartment.GetByDepartmentMock.callArgs = append(mmGetByDepartment.GetByDepartmentMock.callArgs, mm_params)
	mmGetByDepartment.GetByDepartmentMock.mutex.Unlock()

	for _, e := range mmGetByDepartment.GetByDepartmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetByDepartment.GetByDepartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByDepartment.GetByDepartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByDepartment.GetByDepartmentMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetByDepartmentParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByDepartment.t.Errorf("EmployeeRepositoryMock.GetByDepartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByDepartment.GetByDepartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByDepartment.t.Fatal("No results are set for the EmployeeRepositoryMock.GetByDepartment")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetByDepartment.funcGetByDepartment != nil {
		return mmGetByDepartment.funcGetByDepartment(ctx, id)
	}
	mmGetByDepartment.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetByDepartment. %v %v", ctx, id)
	return
}

// GetByDepartmentAfterCounter returns a count of finished EmployeeRepositoryMock.GetByDepartment invocations
func (mmGetByDepartment *EmployeeRepositoryMock) GetByDepartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByDepartment.afterGetByDepartmentCounter)
}

// GetByDepartmentBeforeCounter returns a count of EmployeeRepositoryMock.GetByDepartment invocations
func (mmGetByDepartment *EmployeeRepositoryMock) GetByDepartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByDepartment.beforeGetByDepartmentCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetByDepartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByDepartment *mEmployeeRepositoryMockGetByDepartment) Calls() []*EmployeeRepositoryMockGetByDepartmentParams {
	mmGetByDepartment.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetByDepartmentParams, len(mmGetByDepartment.callArgs))
	copy(argCopy, mmGetByDepartment.callArgs)

	mmGetByDepartment.mutex.RUnlock()

	return argCopy
}

// MinimockGetByDepartmentDone returns true if the count of the GetByDepartment invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetByDepartmentDone() bool {
	for _, e := range m.GetByDepartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByDepartmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByDepartmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByDepartment != nil && mm_atomic.LoadUint64(&m.afterGetByDepartmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByDepartmentInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetByDepartmentInspect() {
	for _, e := range m.GetByDepartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByDepartment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByDepartmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByDepartmentCounter) < 1 {
		if m.GetByDepartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetByDepartment")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByDepartment with params: %#v", *m.GetByDepartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByDepartment != nil && mm_atomic.LoadUint64(&m.afterGetByDepartmentCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetByDepartment")
	}
}

type mEmployeeRepositoryMockGetByID struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetByIDExpectation
	expectations       []*EmployeeRepositoryMockGetByIDExpectation

	callArgs []*EmployeeRepositoryMockGetByIDParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetByIDExpectation specifies expectation struct of the EmployeeRepository.GetByID
type EmployeeRepositoryMockGetByIDExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetByIDParams
	results *EmployeeRepositoryMockGetByIDResults
	Counter uint64
}

// EmployeeRepositoryMockGetByIDParams contains parameters of the EmployeeRepository.GetByID
type EmployeeRepositoryMockGetByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EmployeeRepositoryMockGetByIDResults contains results of the EmployeeRepository.GetByID
type EmployeeRepositoryMockGetByIDResults struct {
	ep1 *models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetByID
func (mmGetByID *mEmployeeRepositoryMockGetByID) Expect(ctx context.Context, id uuid.UUID) *mEmployeeRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepositoryMockGetByIDExpectation{}
	}

	mmGetByID.defaultExpectation.params = &EmployeeRepositoryMockGetByIDParams{ctx, id}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetByID
func (mmGetByID *mEmployeeRepositoryMockGetByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEmployeeRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by EmployeeRepository.GetByID
func (mmGetByID *mEmployeeRepositoryMockGetByID) Return(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &EmployeeRepositoryMockGetByIDResults{ep1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the EmployeeRepository.GetByID method
func (mmGetByID *mEmployeeRepositoryMockGetByID) Set(f func(ctx context.Context, id uuid.UUID) (ep1 *models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the EmployeeRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mEmployeeRepositoryMockGetByID) When(ctx context.Context, id uuid.UUID) *EmployeeRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &EmployeeRepositoryMockGetByIDParams{ctx, id},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetByIDExpectation) Then(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetByIDResults{ep1, err}
	return e.mock
}

// GetByID implements ports.EmployeeRepository
func (mmGetByID *EmployeeRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (ep1 *models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := &EmployeeRepositoryMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("EmployeeRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the EmployeeRepositoryMock.GetByID")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished EmployeeRepositoryMock.GetByID invocations
func (mmGetByID *EmployeeRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of EmployeeRepositoryMock.GetByID invocations
func (mmGetByID *EmployeeRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mEmployeeRepositoryMockGetByID) Calls() []*EmployeeRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetByID")
	}
}

type mEmployeeRepositoryMockGetByNickname struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetByNicknameExpectation
	expectations       []*EmployeeRepositoryMockGetByNicknameExpectation

	callArgs []*EmployeeRepositoryMockGetByNicknameParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetByNicknameExpectation specifies expectation struct of the EmployeeRepository.GetByNickname
type EmployeeRepositoryMockGetByNicknameExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetByNicknameParams
	results *EmployeeRepositoryMockGetByNicknameResults
	Counter uint64
}

// EmployeeRepositoryMockGetByNicknameParams contains parameters of the EmployeeRepository.GetByNickname
type EmployeeRepositoryMockGetByNicknameParams struct {
	ctx      context.Context
	nickname string
}

// EmployeeRepositoryMockGetByNicknameResults contains results of the EmployeeRepository.GetByNickname
type EmployeeRepositoryMockGetByNicknameResults struct {
	ep1 *models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetByNickname
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) Expect(ctx context.Context, nickname string) *mEmployeeRepositoryMockGetByNickname {
	if mmGetByNickname.mock.funcGetByNickname != nil {
		mmGetByNickname.mock.t.Fatalf("EmployeeRepositoryMock.GetByNickname mock is already set by Set")
	}

	if mmGetByNickname.defaultExpectation == nil {
		mmGetByNickname.defaultExpectation = &EmployeeRepositoryMockGetByNicknameExpectation{}
	}

	mmGetByNickname.defaultExpectation.params = &EmployeeRepositoryMockGetByNicknameParams{ctx, nickname}
	for _, e := range mmGetByNickname.expectations {
		if minimock.Equal(e.params, mmGetByNickname.defaultExpectation.params) {
			mmGetByNickname.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByNickname.defaultExpectation.params)
		}
	}

	return mmGetByNickname
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetByNickname
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) Inspect(f func(ctx context.Context, nickname string)) *mEmployeeRepositoryMockGetByNickname {
	if mmGetByNickname.mock.inspectFuncGetByNickname != nil {
		mmGetByNickname.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetByNickname")
	}

	mmGetByNickname.mock.inspectFuncGetByNickname = f

	return mmGetByNickname
}

// Return sets up results that will be returned by EmployeeRepository.GetByNickname
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) Return(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetByNickname.mock.funcGetByNickname != nil {
		mmGetByNickname.mock.t.Fatalf("EmployeeRepositoryMock.GetByNickname mock is already set by Set")
	}

	if mmGetByNickname.defaultExpectation == nil {
		mmGetByNickname.defaultExpectation = &EmployeeRepositoryMockGetByNicknameExpectation{mock: mmGetByNickname.mock}
	}
	mmGetByNickname.defaultExpectation.results = &EmployeeRepositoryMockGetByNicknameResults{ep1, err}
	return mmGetByNickname.mock
}

// Set uses given function f to mock the EmployeeRepository.GetByNickname method
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) Set(f func(ctx context.Context, nickname string) (ep1 *models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetByNickname.defaultExpectation != nil {
		mmGetByNickname.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetByNickname method")
	}

	if len(mmGetByNickname.expectations) > 0 {
		mmGetByNickname.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetByNickname method")
	}

	mmGetByNickname.mock.funcGetByNickname = f
	return mmGetByNickname.mock
}

// When sets expectation for the EmployeeRepository.GetByNickname which will trigger the result defined by the following
// Then helper
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) When(ctx context.Context, nickname string) *EmployeeRepositoryMockGetByNicknameExpectation {
	if mmGetByNickname.mock.funcGetByNickname != nil {
		mmGetByNickname.mock.t.Fatalf("EmployeeRepositoryMock.GetByNickname mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetByNicknameExpectation{
		mock:   mmGetByNickname.mock,
		params: &EmployeeRepositoryMockGetByNicknameParams{ctx, nickname},
	}
	mmGetByNickname.expectations = append(mmGetByNickname.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetByNickname return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetByNicknameExpectation) Then(ep1 *models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetByNicknameResults{ep1, err}
	return e.mock
}

// GetByNickname implements ports.EmployeeRepository
func (mmGetByNickname *EmployeeRepositoryMock) GetByNickname(ctx context.Context, nickname string) (ep1 *models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByNickname.beforeGetByNicknameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByNickname.afterGetByNicknameCounter, 1)

	if mmGetByNickname.inspectFuncGetByNickname != nil {
		mmGetByNickname.inspectFuncGetByNickname(ctx, nickname)
	}

	mm_params := &EmployeeRepositoryMockGetByNicknameParams{ctx, nickname}

	// Record call args
	mmGetByNickname.GetByNicknameMock.mutex.Lock()
	mmGetByNickname.GetByNicknameMock.callArgs = append(mmGetByNickname.GetByNicknameMock.callArgs, mm_params)
	mmGetByNickname.GetByNicknameMock.mutex.Unlock()

	for _, e := range mmGetByNickname.GetByNicknameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmGetByNickname.GetByNicknameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByNickname.GetByNicknameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByNickname.GetByNicknameMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetByNicknameParams{ctx, nickname}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByNickname.t.Errorf("EmployeeRepositoryMock.GetByNickname got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByNickname.GetByNicknameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByNickname.t.Fatal("No results are set for the EmployeeRepositoryMock.GetByNickname")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmGetByNickname.funcGetByNickname != nil {
		return mmGetByNickname.funcGetByNickname(ctx, nickname)
	}
	mmGetByNickname.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetByNickname. %v %v", ctx, nickname)
	return
}

// GetByNicknameAfterCounter returns a count of finished EmployeeRepositoryMock.GetByNickname invocations
func (mmGetByNickname *EmployeeRepositoryMock) GetByNicknameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByNickname.afterGetByNicknameCounter)
}

// GetByNicknameBeforeCounter returns a count of EmployeeRepositoryMock.GetByNickname invocations
func (mmGetByNickname *EmployeeRepositoryMock) GetByNicknameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByNickname.beforeGetByNicknameCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetByNickname.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByNickname *mEmployeeRepositoryMockGetByNickname) Calls() []*EmployeeRepositoryMockGetByNicknameParams {
	mmGetByNickname.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetByNicknameParams, len(mmGetByNickname.callArgs))
	copy(argCopy, mmGetByNickname.callArgs)

	mmGetByNickname.mutex.RUnlock()

	return argCopy
}

// MinimockGetByNicknameDone returns true if the count of the GetByNickname invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetByNicknameDone() bool {
	for _, e := range m.GetByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByNicknameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByNicknameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByNickname != nil && mm_atomic.LoadUint64(&m.afterGetByNicknameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByNicknameInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetByNicknameInspect() {
	for _, e := range m.GetByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByNickname with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByNicknameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByNicknameCounter) < 1 {
		if m.GetByNicknameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetByNickname")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByNickname with params: %#v", *m.GetByNicknameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByNickname != nil && mm_atomic.LoadUint64(&m.afterGetByNicknameCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetByNickname")
	}
}

type mEmployeeRepositoryMockGetByTeam struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockGetByTeamExpectation
	expectations       []*EmployeeRepositoryMockGetByTeamExpectation

	callArgs []*EmployeeRepositoryMockGetByTeamParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockGetByTeamExpectation specifies expectation struct of the EmployeeRepository.GetByTeam
type EmployeeRepositoryMockGetByTeamExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockGetByTeamParams
	results *EmployeeRepositoryMockGetByTeamResults
	Counter uint64
}

// EmployeeRepositoryMockGetByTeamParams contains parameters of the EmployeeRepository.GetByTeam
type EmployeeRepositoryMockGetByTeamParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EmployeeRepositoryMockGetByTeamResults contains results of the EmployeeRepository.GetByTeam
type EmployeeRepositoryMockGetByTeamResults struct {
	ea1 []models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.GetByTeam
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) Expect(ctx context.Context, id uuid.UUID) *mEmployeeRepositoryMockGetByTeam {
	if mmGetByTeam.mock.funcGetByTeam != nil {
		mmGetByTeam.mock.t.Fatalf("EmployeeRepositoryMock.GetByTeam mock is already set by Set")
	}

	if mmGetByTeam.defaultExpectation == nil {
		mmGetByTeam.defaultExpectation = &EmployeeRepositoryMockGetByTeamExpectation{}
	}

	mmGetByTeam.defaultExpectation.params = &EmployeeRepositoryMockGetByTeamParams{ctx, id}
	for _, e := range mmGetByTeam.expectations {
		if minimock.Equal(e.params, mmGetByTeam.defaultExpectation.params) {
			mmGetByTeam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByTeam.defaultExpectation.params)
		}
	}

	return mmGetByTeam
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.GetByTeam
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEmployeeRepositoryMockGetByTeam {
	if mmGetByTeam.mock.inspectFuncGetByTeam != nil {
		mmGetByTeam.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.GetByTeam")
	}

	mmGetByTeam.mock.inspectFuncGetByTeam = f

	return mmGetByTeam
}

// Return sets up results that will be returned by EmployeeRepository.GetByTeam
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) Return(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	if mmGetByTeam.mock.funcGetByTeam != nil {
		mmGetByTeam.mock.t.Fatalf("EmployeeRepositoryMock.GetByTeam mock is already set by Set")
	}

	if mmGetByTeam.defaultExpectation == nil {
		mmGetByTeam.defaultExpectation = &EmployeeRepositoryMockGetByTeamExpectation{mock: mmGetByTeam.mock}
	}
	mmGetByTeam.defaultExpectation.results = &EmployeeRepositoryMockGetByTeamResults{ea1, err}
	return mmGetByTeam.mock
}

// Set uses given function f to mock the EmployeeRepository.GetByTeam method
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) Set(f func(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error)) *EmployeeRepositoryMock {
	if mmGetByTeam.defaultExpectation != nil {
		mmGetByTeam.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.GetByTeam method")
	}

	if len(mmGetByTeam.expectations) > 0 {
		mmGetByTeam.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.GetByTeam method")
	}

	mmGetByTeam.mock.funcGetByTeam = f
	return mmGetByTeam.mock
}

// When sets expectation for the EmployeeRepository.GetByTeam which will trigger the result defined by the following
// Then helper
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) When(ctx context.Context, id uuid.UUID) *EmployeeRepositoryMockGetByTeamExpectation {
	if mmGetByTeam.mock.funcGetByTeam != nil {
		mmGetByTeam.mock.t.Fatalf("EmployeeRepositoryMock.GetByTeam mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockGetByTeamExpectation{
		mock:   mmGetByTeam.mock,
		params: &EmployeeRepositoryMockGetByTeamParams{ctx, id},
	}
	mmGetByTeam.expectations = append(mmGetByTeam.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.GetByTeam return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockGetByTeamExpectation) Then(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockGetByTeamResults{ea1, err}
	return e.mock
}

// GetByTeam implements ports.EmployeeRepository
func (mmGetByTeam *EmployeeRepositoryMock) GetByTeam(ctx context.Context, id uuid.UUID) (ea1 []models.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByTeam.beforeGetByTeamCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByTeam.afterGetByTeamCounter, 1)

	if mmGetByTeam.inspectFuncGetByTeam != nil {
		mmGetByTeam.inspectFuncGetByTeam(ctx, id)
	}

	mm_params := &EmployeeRepositoryMockGetByTeamParams{ctx, id}

	// Record call args
	mmGetByTeam.GetByTeamMock.mutex.Lock()
	mmGetByTeam.GetByTeamMock.callArgs = append(mmGetByTeam.GetByTeamMock.callArgs, mm_params)
	mmGetByTeam.GetByTeamMock.mutex.Unlock()

	for _, e := range mmGetByTeam.GetByTeamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetByTeam.GetByTeamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByTeam.GetByTeamMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByTeam.GetByTeamMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockGetByTeamParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByTeam.t.Errorf("EmployeeRepositoryMock.GetByTeam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByTeam.GetByTeamMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByTeam.t.Fatal("No results are set for the EmployeeRepositoryMock.GetByTeam")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetByTeam.funcGetByTeam != nil {
		return mmGetByTeam.funcGetByTeam(ctx, id)
	}
	mmGetByTeam.t.Fatalf("Unexpected call to EmployeeRepositoryMock.GetByTeam. %v %v", ctx, id)
	return
}

// GetByTeamAfterCounter returns a count of finished EmployeeRepositoryMock.GetByTeam invocations
func (mmGetByTeam *EmployeeRepositoryMock) GetByTeamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByTeam.afterGetByTeamCounter)
}

// GetByTeamBeforeCounter returns a count of EmployeeRepositoryMock.GetByTeam invocations
func (mmGetByTeam *EmployeeRepositoryMock) GetByTeamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByTeam.beforeGetByTeamCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.GetByTeam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByTeam *mEmployeeRepositoryMockGetByTeam) Calls() []*EmployeeRepositoryMockGetByTeamParams {
	mmGetByTeam.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockGetByTeamParams, len(mmGetByTeam.callArgs))
	copy(argCopy, mmGetByTeam.callArgs)

	mmGetByTeam.mutex.RUnlock()

	return argCopy
}

// MinimockGetByTeamDone returns true if the count of the GetByTeam invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockGetByTeamDone() bool {
	for _, e := range m.GetByTeamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByTeamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByTeamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByTeam != nil && mm_atomic.LoadUint64(&m.afterGetByTeamCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByTeamInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockGetByTeamInspect() {
	for _, e := range m.GetByTeamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByTeam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByTeamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByTeamCounter) < 1 {
		if m.GetByTeamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.GetByTeam")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.GetByTeam with params: %#v", *m.GetByTeamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByTeam != nil && mm_atomic.LoadUint64(&m.afterGetByTeamCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.GetByTeam")
	}
}

type mEmployeeRepositoryMockListSimilarByName struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockListSimilarByNameExpectation
	expectations       []*EmployeeRepositoryMockListSimilarByNameExpectation

	callArgs []*EmployeeRepositoryMockListSimilarByNameParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockListSimilarByNameExpectation specifies expectation struct of the EmployeeRepository.ListSimilarByName
type EmployeeRepositoryMockListSimilarByNameExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockListSimilarByNameParams
	results *EmployeeRepositoryMockListSimilarByNameResults
	Counter uint64
}

// EmployeeRepositoryMockListSimilarByNameParams contains parameters of the EmployeeRepository.ListSimilarByName
type EmployeeRepositoryMockListSimilarByNameParams struct {
	ctx    context.Context
	substr string
}

// EmployeeRepositoryMockListSimilarByNameResults contains results of the EmployeeRepository.ListSimilarByName
type EmployeeRepositoryMockListSimilarByNameResults struct {
	ea1 []models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.ListSimilarByName
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) Expect(ctx context.Context, substr string) *mEmployeeRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &EmployeeRepositoryMockListSimilarByNameExpectation{}
	}

	mmListSimilarByName.defaultExpectation.params = &EmployeeRepositoryMockListSimilarByNameParams{ctx, substr}
	for _, e := range mmListSimilarByName.expectations {
		if minimock.Equal(e.params, mmListSimilarByName.defaultExpectation.params) {
			mmListSimilarByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSimilarByName.defaultExpectation.params)
		}
	}

	return mmListSimilarByName
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.ListSimilarByName
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) Inspect(f func(ctx context.Context, substr string)) *mEmployeeRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.ListSimilarByName")
	}

	mmListSimilarByName.mock.inspectFuncListSimilarByName = f

	return mmListSimilarByName
}

// Return sets up results that will be returned by EmployeeRepository.ListSimilarByName
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) Return(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &EmployeeRepositoryMockListSimilarByNameExpectation{mock: mmListSimilarByName.mock}
	}
	mmListSimilarByName.defaultExpectation.results = &EmployeeRepositoryMockListSimilarByNameResults{ea1, err}
	return mmListSimilarByName.mock
}

// Set uses given function f to mock the EmployeeRepository.ListSimilarByName method
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) Set(f func(ctx context.Context, substr string) (ea1 []models.Employee, err error)) *EmployeeRepositoryMock {
	if mmListSimilarByName.defaultExpectation != nil {
		mmListSimilarByName.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.ListSimilarByName method")
	}

	if len(mmListSimilarByName.expectations) > 0 {
		mmListSimilarByName.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.ListSimilarByName method")
	}

	mmListSimilarByName.mock.funcListSimilarByName = f
	return mmListSimilarByName.mock
}

// When sets expectation for the EmployeeRepository.ListSimilarByName which will trigger the result defined by the following
// Then helper
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) When(ctx context.Context, substr string) *EmployeeRepositoryMockListSimilarByNameExpectation {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockListSimilarByNameExpectation{
		mock:   mmListSimilarByName.mock,
		params: &EmployeeRepositoryMockListSimilarByNameParams{ctx, substr},
	}
	mmListSimilarByName.expectations = append(mmListSimilarByName.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.ListSimilarByName return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockListSimilarByNameExpectation) Then(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockListSimilarByNameResults{ea1, err}
	return e.mock
}

// ListSimilarByName implements ports.EmployeeRepository
func (mmListSimilarByName *EmployeeRepositoryMock) ListSimilarByName(ctx context.Context, substr string) (ea1 []models.Employee, err error) {
	mm_atomic.AddUint64(&mmListSimilarByName.beforeListSimilarByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmListSimilarByName.afterListSimilarByNameCounter, 1)

	if mmListSimilarByName.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.inspectFuncListSimilarByName(ctx, substr)
	}

	mm_params := &EmployeeRepositoryMockListSimilarByNameParams{ctx, substr}

	// Record call args
	mmListSimilarByName.ListSimilarByNameMock.mutex.Lock()
	mmListSimilarByName.ListSimilarByNameMock.callArgs = append(mmListSimilarByName.ListSimilarByNameMock.callArgs, mm_params)
	mmListSimilarByName.ListSimilarByNameMock.mutex.Unlock()

	for _, e := range mmListSimilarByName.ListSimilarByNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListSimilarByName.ListSimilarByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockListSimilarByNameParams{ctx, substr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSimilarByName.t.Errorf("EmployeeRepositoryMock.ListSimilarByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmListSimilarByName.t.Fatal("No results are set for the EmployeeRepositoryMock.ListSimilarByName")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListSimilarByName.funcListSimilarByName != nil {
		return mmListSimilarByName.funcListSimilarByName(ctx, substr)
	}
	mmListSimilarByName.t.Fatalf("Unexpected call to EmployeeRepositoryMock.ListSimilarByName. %v %v", ctx, substr)
	return
}

// ListSimilarByNameAfterCounter returns a count of finished EmployeeRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *EmployeeRepositoryMock) ListSimilarByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.afterListSimilarByNameCounter)
}

// ListSimilarByNameBeforeCounter returns a count of EmployeeRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *EmployeeRepositoryMock) ListSimilarByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.beforeListSimilarByNameCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.ListSimilarByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSimilarByName *mEmployeeRepositoryMockListSimilarByName) Calls() []*EmployeeRepositoryMockListSimilarByNameParams {
	mmListSimilarByName.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockListSimilarByNameParams, len(mmListSimilarByName.callArgs))
	copy(argCopy, mmListSimilarByName.callArgs)

	mmListSimilarByName.mutex.RUnlock()

	return argCopy
}

// MinimockListSimilarByNameDone returns true if the count of the ListSimilarByName invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockListSimilarByNameDone() bool {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSimilarByNameInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockListSimilarByNameInspect() {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.ListSimilarByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		if m.ListSimilarByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.ListSimilarByName")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.ListSimilarByName with params: %#v", *m.ListSimilarByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.ListSimilarByName")
	}
}

type mEmployeeRepositoryMockListSimilarByNickname struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockListSimilarByNicknameExpectation
	expectations       []*EmployeeRepositoryMockListSimilarByNicknameExpectation

	callArgs []*EmployeeRepositoryMockListSimilarByNicknameParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockListSimilarByNicknameExpectation specifies expectation struct of the EmployeeRepository.ListSimilarByNickname
type EmployeeRepositoryMockListSimilarByNicknameExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockListSimilarByNicknameParams
	results *EmployeeRepositoryMockListSimilarByNicknameResults
	Counter uint64
}

// EmployeeRepositoryMockListSimilarByNicknameParams contains parameters of the EmployeeRepository.ListSimilarByNickname
type EmployeeRepositoryMockListSimilarByNicknameParams struct {
	ctx    context.Context
	substr string
}

// EmployeeRepositoryMockListSimilarByNicknameResults contains results of the EmployeeRepository.ListSimilarByNickname
type EmployeeRepositoryMockListSimilarByNicknameResults struct {
	ea1 []models.Employee
	err error
}

// Expect sets up expected params for EmployeeRepository.ListSimilarByNickname
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) Expect(ctx context.Context, substr string) *mEmployeeRepositoryMockListSimilarByNickname {
	if mmListSimilarByNickname.mock.funcListSimilarByNickname != nil {
		mmListSimilarByNickname.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByNickname mock is already set by Set")
	}

	if mmListSimilarByNickname.defaultExpectation == nil {
		mmListSimilarByNickname.defaultExpectation = &EmployeeRepositoryMockListSimilarByNicknameExpectation{}
	}

	mmListSimilarByNickname.defaultExpectation.params = &EmployeeRepositoryMockListSimilarByNicknameParams{ctx, substr}
	for _, e := range mmListSimilarByNickname.expectations {
		if minimock.Equal(e.params, mmListSimilarByNickname.defaultExpectation.params) {
			mmListSimilarByNickname.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSimilarByNickname.defaultExpectation.params)
		}
	}

	return mmListSimilarByNickname
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.ListSimilarByNickname
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) Inspect(f func(ctx context.Context, substr string)) *mEmployeeRepositoryMockListSimilarByNickname {
	if mmListSimilarByNickname.mock.inspectFuncListSimilarByNickname != nil {
		mmListSimilarByNickname.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.ListSimilarByNickname")
	}

	mmListSimilarByNickname.mock.inspectFuncListSimilarByNickname = f

	return mmListSimilarByNickname
}

// Return sets up results that will be returned by EmployeeRepository.ListSimilarByNickname
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) Return(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	if mmListSimilarByNickname.mock.funcListSimilarByNickname != nil {
		mmListSimilarByNickname.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByNickname mock is already set by Set")
	}

	if mmListSimilarByNickname.defaultExpectation == nil {
		mmListSimilarByNickname.defaultExpectation = &EmployeeRepositoryMockListSimilarByNicknameExpectation{mock: mmListSimilarByNickname.mock}
	}
	mmListSimilarByNickname.defaultExpectation.results = &EmployeeRepositoryMockListSimilarByNicknameResults{ea1, err}
	return mmListSimilarByNickname.mock
}

// Set uses given function f to mock the EmployeeRepository.ListSimilarByNickname method
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) Set(f func(ctx context.Context, substr string) (ea1 []models.Employee, err error)) *EmployeeRepositoryMock {
	if mmListSimilarByNickname.defaultExpectation != nil {
		mmListSimilarByNickname.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.ListSimilarByNickname method")
	}

	if len(mmListSimilarByNickname.expectations) > 0 {
		mmListSimilarByNickname.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.ListSimilarByNickname method")
	}

	mmListSimilarByNickname.mock.funcListSimilarByNickname = f
	return mmListSimilarByNickname.mock
}

// When sets expectation for the EmployeeRepository.ListSimilarByNickname which will trigger the result defined by the following
// Then helper
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) When(ctx context.Context, substr string) *EmployeeRepositoryMockListSimilarByNicknameExpectation {
	if mmListSimilarByNickname.mock.funcListSimilarByNickname != nil {
		mmListSimilarByNickname.mock.t.Fatalf("EmployeeRepositoryMock.ListSimilarByNickname mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockListSimilarByNicknameExpectation{
		mock:   mmListSimilarByNickname.mock,
		params: &EmployeeRepositoryMockListSimilarByNicknameParams{ctx, substr},
	}
	mmListSimilarByNickname.expectations = append(mmListSimilarByNickname.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.ListSimilarByNickname return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockListSimilarByNicknameExpectation) Then(ea1 []models.Employee, err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockListSimilarByNicknameResults{ea1, err}
	return e.mock
}

// ListSimilarByNickname implements ports.EmployeeRepository
func (mmListSimilarByNickname *EmployeeRepositoryMock) ListSimilarByNickname(ctx context.Context, substr string) (ea1 []models.Employee, err error) {
	mm_atomic.AddUint64(&mmListSimilarByNickname.beforeListSimilarByNicknameCounter, 1)
	defer mm_atomic.AddUint64(&mmListSimilarByNickname.afterListSimilarByNicknameCounter, 1)

	if mmListSimilarByNickname.inspectFuncListSimilarByNickname != nil {
		mmListSimilarByNickname.inspectFuncListSimilarByNickname(ctx, substr)
	}

	mm_params := &EmployeeRepositoryMockListSimilarByNicknameParams{ctx, substr}

	// Record call args
	mmListSimilarByNickname.ListSimilarByNicknameMock.mutex.Lock()
	mmListSimilarByNickname.ListSimilarByNicknameMock.callArgs = append(mmListSimilarByNickname.ListSimilarByNicknameMock.callArgs, mm_params)
	mmListSimilarByNickname.ListSimilarByNicknameMock.mutex.Unlock()

	for _, e := range mmListSimilarByNickname.ListSimilarByNicknameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListSimilarByNickname.ListSimilarByNicknameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSimilarByNickname.ListSimilarByNicknameMock.defaultExpectation.Counter, 1)
		mm_want := mmListSimilarByNickname.ListSimilarByNicknameMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockListSimilarByNicknameParams{ctx, substr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSimilarByNickname.t.Errorf("EmployeeRepositoryMock.ListSimilarByNickname got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSimilarByNickname.ListSimilarByNicknameMock.defaultExpectation.results
		if mm_results == nil {
			mmListSimilarByNickname.t.Fatal("No results are set for the EmployeeRepositoryMock.ListSimilarByNickname")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListSimilarByNickname.funcListSimilarByNickname != nil {
		return mmListSimilarByNickname.funcListSimilarByNickname(ctx, substr)
	}
	mmListSimilarByNickname.t.Fatalf("Unexpected call to EmployeeRepositoryMock.ListSimilarByNickname. %v %v", ctx, substr)
	return
}

// ListSimilarByNicknameAfterCounter returns a count of finished EmployeeRepositoryMock.ListSimilarByNickname invocations
func (mmListSimilarByNickname *EmployeeRepositoryMock) ListSimilarByNicknameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByNickname.afterListSimilarByNicknameCounter)
}

// ListSimilarByNicknameBeforeCounter returns a count of EmployeeRepositoryMock.ListSimilarByNickname invocations
func (mmListSimilarByNickname *EmployeeRepositoryMock) ListSimilarByNicknameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByNickname.beforeListSimilarByNicknameCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.ListSimilarByNickname.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSimilarByNickname *mEmployeeRepositoryMockListSimilarByNickname) Calls() []*EmployeeRepositoryMockListSimilarByNicknameParams {
	mmListSimilarByNickname.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockListSimilarByNicknameParams, len(mmListSimilarByNickname.callArgs))
	copy(argCopy, mmListSimilarByNickname.callArgs)

	mmListSimilarByNickname.mutex.RUnlock()

	return argCopy
}

// MinimockListSimilarByNicknameDone returns true if the count of the ListSimilarByNickname invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockListSimilarByNicknameDone() bool {
	for _, e := range m.ListSimilarByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNicknameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNicknameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByNickname != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNicknameCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSimilarByNicknameInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockListSimilarByNicknameInspect() {
	for _, e := range m.ListSimilarByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.ListSimilarByNickname with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNicknameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNicknameCounter) < 1 {
		if m.ListSimilarByNicknameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.ListSimilarByNickname")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.ListSimilarByNickname with params: %#v", *m.ListSimilarByNicknameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByNickname != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNicknameCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.ListSimilarByNickname")
	}
}

type mEmployeeRepositoryMockSoftDelete struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockSoftDeleteExpectation
	expectations       []*EmployeeRepositoryMockSoftDeleteExpectation

	callArgs []*EmployeeRepositoryMockSoftDeleteParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockSoftDeleteExpectation specifies expectation struct of the EmployeeRepository.SoftDelete
type EmployeeRepositoryMockSoftDeleteExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockSoftDeleteParams
	results *EmployeeRepositoryMockSoftDeleteResults
	Counter uint64
}

// EmployeeRepositoryMockSoftDeleteParams contains parameters of the EmployeeRepository.SoftDelete
type EmployeeRepositoryMockSoftDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EmployeeRepositoryMockSoftDeleteResults contains results of the EmployeeRepository.SoftDelete
type EmployeeRepositoryMockSoftDeleteResults struct {
	err error
}

// Expect sets up expected params for EmployeeRepository.SoftDelete
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) Expect(ctx context.Context, id uuid.UUID) *mEmployeeRepositoryMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("EmployeeRepositoryMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &EmployeeRepositoryMockSoftDeleteExpectation{}
	}

	mmSoftDelete.defaultExpectation.params = &EmployeeRepositoryMockSoftDeleteParams{ctx, id}
	for _, e := range mmSoftDelete.expectations {
		if minimock.Equal(e.params, mmSoftDelete.defaultExpectation.params) {
			mmSoftDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSoftDelete.defaultExpectation.params)
		}
	}

	return mmSoftDelete
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.SoftDelete
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEmployeeRepositoryMockSoftDelete {
	if mmSoftDelete.mock.inspectFuncSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.SoftDelete")
	}

	mmSoftDelete.mock.inspectFuncSoftDelete = f

	return mmSoftDelete
}

// Return sets up results that will be returned by EmployeeRepository.SoftDelete
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) Return(err error) *EmployeeRepositoryMock {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("EmployeeRepositoryMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &EmployeeRepositoryMockSoftDeleteExpectation{mock: mmSoftDelete.mock}
	}
	mmSoftDelete.defaultExpectation.results = &EmployeeRepositoryMockSoftDeleteResults{err}
	return mmSoftDelete.mock
}

// Set uses given function f to mock the EmployeeRepository.SoftDelete method
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *EmployeeRepositoryMock {
	if mmSoftDelete.defaultExpectation != nil {
		mmSoftDelete.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.SoftDelete method")
	}

	if len(mmSoftDelete.expectations) > 0 {
		mmSoftDelete.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.SoftDelete method")
	}

	mmSoftDelete.mock.funcSoftDelete = f
	return mmSoftDelete.mock
}

// When sets expectation for the EmployeeRepository.SoftDelete which will trigger the result defined by the following
// Then helper
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) When(ctx context.Context, id uuid.UUID) *EmployeeRepositoryMockSoftDeleteExpectation {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("EmployeeRepositoryMock.SoftDelete mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockSoftDeleteExpectation{
		mock:   mmSoftDelete.mock,
		params: &EmployeeRepositoryMockSoftDeleteParams{ctx, id},
	}
	mmSoftDelete.expectations = append(mmSoftDelete.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.SoftDelete return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockSoftDeleteExpectation) Then(err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockSoftDeleteResults{err}
	return e.mock
}

// SoftDelete implements ports.EmployeeRepository
func (mmSoftDelete *EmployeeRepositoryMock) SoftDelete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSoftDelete.beforeSoftDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmSoftDelete.afterSoftDeleteCounter, 1)

	if mmSoftDelete.inspectFuncSoftDelete != nil {
		mmSoftDelete.inspectFuncSoftDelete(ctx, id)
	}

	mm_params := &EmployeeRepositoryMockSoftDeleteParams{ctx, id}

	// Record call args
	mmSoftDelete.SoftDeleteMock.mutex.Lock()
	mmSoftDelete.SoftDeleteMock.callArgs = append(mmSoftDelete.SoftDeleteMock.callArgs, mm_params)
	mmSoftDelete.SoftDeleteMock.mutex.Unlock()

	for _, e := range mmSoftDelete.SoftDeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSoftDelete.SoftDeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSoftDelete.SoftDeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmSoftDelete.SoftDeleteMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockSoftDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSoftDelete.t.Errorf("EmployeeRepositoryMock.SoftDelete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSoftDelete.SoftDeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmSoftDelete.t.Fatal("No results are set for the EmployeeRepositoryMock.SoftDelete")
		}
		return (*mm_results).err
	}
	if mmSoftDelete.funcSoftDelete != nil {
		return mmSoftDelete.funcSoftDelete(ctx, id)
	}
	mmSoftDelete.t.Fatalf("Unexpected call to EmployeeRepositoryMock.SoftDelete. %v %v", ctx, id)
	return
}

// SoftDeleteAfterCounter returns a count of finished EmployeeRepositoryMock.SoftDelete invocations
func (mmSoftDelete *EmployeeRepositoryMock) SoftDeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.afterSoftDeleteCounter)
}

// SoftDeleteBeforeCounter returns a count of EmployeeRepositoryMock.SoftDelete invocations
func (mmSoftDelete *EmployeeRepositoryMock) SoftDeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.beforeSoftDeleteCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.SoftDelete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSoftDelete *mEmployeeRepositoryMockSoftDelete) Calls() []*EmployeeRepositoryMockSoftDeleteParams {
	mmSoftDelete.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockSoftDeleteParams, len(mmSoftDelete.callArgs))
	copy(argCopy, mmSoftDelete.callArgs)

	mmSoftDelete.mutex.RUnlock()

	return argCopy
}

// MinimockSoftDeleteDone returns true if the count of the SoftDelete invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockSoftDeleteDone() bool {
	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SoftDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSoftDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSoftDelete != nil && mm_atomic.LoadUint64(&m.afterSoftDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockSoftDeleteInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockSoftDeleteInspect() {
	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.SoftDelete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SoftDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSoftDeleteCounter) < 1 {
		if m.SoftDeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.SoftDelete")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.SoftDelete with params: %#v", *m.SoftDeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSoftDelete != nil && mm_atomic.LoadUint64(&m.afterSoftDeleteCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.SoftDelete")
	}
}

type mEmployeeRepositoryMockUpdate struct {
	mock               *EmployeeRepositoryMock
	defaultExpectation *EmployeeRepositoryMockUpdateExpectation
	expectations       []*EmployeeRepositoryMockUpdateExpectation

	callArgs []*EmployeeRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// EmployeeRepositoryMockUpdateExpectation specifies expectation struct of the EmployeeRepository.Update
type EmployeeRepositoryMockUpdateExpectation struct {
	mock    *EmployeeRepositoryMock
	params  *EmployeeRepositoryMockUpdateParams
	results *EmployeeRepositoryMockUpdateResults
	Counter uint64
}

// EmployeeRepositoryMockUpdateParams contains parameters of the EmployeeRepository.Update
type EmployeeRepositoryMockUpdateParams struct {
	ctx context.Context
	emp models.Employee
}

// EmployeeRepositoryMockUpdateResults contains results of the EmployeeRepository.Update
type EmployeeRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for EmployeeRepository.Update
func (mmUpdate *mEmployeeRepositoryMockUpdate) Expect(ctx context.Context, emp models.Employee) *mEmployeeRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("EmployeeRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &EmployeeRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &EmployeeRepositoryMockUpdateParams{ctx, emp}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the EmployeeRepository.Update
func (mmUpdate *mEmployeeRepositoryMockUpdate) Inspect(f func(ctx context.Context, emp models.Employee)) *mEmployeeRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for EmployeeRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by EmployeeRepository.Update
func (mmUpdate *mEmployeeRepositoryMockUpdate) Return(err error) *EmployeeRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("EmployeeRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &EmployeeRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &EmployeeRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the EmployeeRepository.Update method
func (mmUpdate *mEmployeeRepositoryMockUpdate) Set(f func(ctx context.Context, emp models.Employee) (err error)) *EmployeeRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the EmployeeRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the EmployeeRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the EmployeeRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mEmployeeRepositoryMockUpdate) When(ctx context.Context, emp models.Employee) *EmployeeRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("EmployeeRepositoryMock.Update mock is already set by Set")
	}

	expectation := &EmployeeRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &EmployeeRepositoryMockUpdateParams{ctx, emp},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up EmployeeRepository.Update return parameters for the expectation previously defined by the When method
func (e *EmployeeRepositoryMockUpdateExpectation) Then(err error) *EmployeeRepositoryMock {
	e.results = &EmployeeRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements ports.EmployeeRepository
func (mmUpdate *EmployeeRepositoryMock) Update(ctx context.Context, emp models.Employee) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, emp)
	}

	mm_params := &EmployeeRepositoryMockUpdateParams{ctx, emp}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := EmployeeRepositoryMockUpdateParams{ctx, emp}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("EmployeeRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the EmployeeRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, emp)
	}
	mmUpdate.t.Fatalf("Unexpected call to EmployeeRepositoryMock.Update. %v %v", ctx, emp)
	return
}

// UpdateAfterCounter returns a count of finished EmployeeRepositoryMock.Update invocations
func (mmUpdate *EmployeeRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of EmployeeRepositoryMock.Update invocations
func (mmUpdate *EmployeeRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mEmployeeRepositoryMockUpdate) Calls() []*EmployeeRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*EmployeeRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *EmployeeRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *EmployeeRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to EmployeeRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EmployeeRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetAllInspect()

		m.MinimockGetByCredentialsInspect()

		m.MinimockGetByDepartmentInspect()

		m.MinimockGetByIDInspect()

		m.MinimockGetByNicknameInspect()

		m.MinimockGetByTeamInspect()

		m.MinimockListSimilarByNameInspect()

		m.MinimockListSimilarByNicknameInspect()

		m.MinimockSoftDeleteInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EmployeeRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EmployeeRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByCredentialsDone() &&
		m.MinimockGetByDepartmentDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockGetByNicknameDone() &&
		m.MinimockGetByTeamDone() &&
		m.MinimockListSimilarByNameDone() &&
		m.MinimockListSimilarByNicknameDone() &&
		m.MinimockSoftDeleteDone() &&
		m.MinimockUpdateDone()
}
