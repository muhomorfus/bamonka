package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/ports.SubscriptionRepository -o ./internal/mocks/subscription_repository_mock.go -n SubscriptionRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// SubscriptionRepositoryMock implements ports.SubscriptionRepository
type SubscriptionRepositoryMock struct {
	t minimock.Tester

	funcIsSubscribed          func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (b1 bool, err error)
	inspectFuncIsSubscribed   func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)
	afterIsSubscribedCounter  uint64
	beforeIsSubscribedCounter uint64
	IsSubscribedMock          mSubscriptionRepositoryMockIsSubscribed

	funcSubscribe          func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error)
	inspectFuncSubscribe   func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mSubscriptionRepositoryMockSubscribe

	funcUnsubscribe          func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error)
	inspectFuncUnsubscribe   func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)
	afterUnsubscribeCounter  uint64
	beforeUnsubscribeCounter uint64
	UnsubscribeMock          mSubscriptionRepositoryMockUnsubscribe
}

// NewSubscriptionRepositoryMock returns a mock for ports.SubscriptionRepository
func NewSubscriptionRepositoryMock(t minimock.Tester) *SubscriptionRepositoryMock {
	m := &SubscriptionRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsSubscribedMock = mSubscriptionRepositoryMockIsSubscribed{mock: m}
	m.IsSubscribedMock.callArgs = []*SubscriptionRepositoryMockIsSubscribedParams{}

	m.SubscribeMock = mSubscriptionRepositoryMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*SubscriptionRepositoryMockSubscribeParams{}

	m.UnsubscribeMock = mSubscriptionRepositoryMockUnsubscribe{mock: m}
	m.UnsubscribeMock.callArgs = []*SubscriptionRepositoryMockUnsubscribeParams{}

	return m
}

type mSubscriptionRepositoryMockIsSubscribed struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockIsSubscribedExpectation
	expectations       []*SubscriptionRepositoryMockIsSubscribedExpectation

	callArgs []*SubscriptionRepositoryMockIsSubscribedParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockIsSubscribedExpectation specifies expectation struct of the SubscriptionRepository.IsSubscribed
type SubscriptionRepositoryMockIsSubscribedExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockIsSubscribedParams
	results *SubscriptionRepositoryMockIsSubscribedResults
	Counter uint64
}

// SubscriptionRepositoryMockIsSubscribedParams contains parameters of the SubscriptionRepository.IsSubscribed
type SubscriptionRepositoryMockIsSubscribedParams struct {
	ctx        context.Context
	subscriber uuid.UUID
	author     uuid.UUID
}

// SubscriptionRepositoryMockIsSubscribedResults contains results of the SubscriptionRepository.IsSubscribed
type SubscriptionRepositoryMockIsSubscribedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for SubscriptionRepository.IsSubscribed
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) Expect(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *mSubscriptionRepositoryMockIsSubscribed {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("SubscriptionRepositoryMock.IsSubscribed mock is already set by Set")
	}

	if mmIsSubscribed.defaultExpectation == nil {
		mmIsSubscribed.defaultExpectation = &SubscriptionRepositoryMockIsSubscribedExpectation{}
	}

	mmIsSubscribed.defaultExpectation.params = &SubscriptionRepositoryMockIsSubscribedParams{ctx, subscriber, author}
	for _, e := range mmIsSubscribed.expectations {
		if minimock.Equal(e.params, mmIsSubscribed.defaultExpectation.params) {
			mmIsSubscribed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSubscribed.defaultExpectation.params)
		}
	}

	return mmIsSubscribed
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.IsSubscribed
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) Inspect(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)) *mSubscriptionRepositoryMockIsSubscribed {
	if mmIsSubscribed.mock.inspectFuncIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.IsSubscribed")
	}

	mmIsSubscribed.mock.inspectFuncIsSubscribed = f

	return mmIsSubscribed
}

// Return sets up results that will be returned by SubscriptionRepository.IsSubscribed
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) Return(b1 bool, err error) *SubscriptionRepositoryMock {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("SubscriptionRepositoryMock.IsSubscribed mock is already set by Set")
	}

	if mmIsSubscribed.defaultExpectation == nil {
		mmIsSubscribed.defaultExpectation = &SubscriptionRepositoryMockIsSubscribedExpectation{mock: mmIsSubscribed.mock}
	}
	mmIsSubscribed.defaultExpectation.results = &SubscriptionRepositoryMockIsSubscribedResults{b1, err}
	return mmIsSubscribed.mock
}

// Set uses given function f to mock the SubscriptionRepository.IsSubscribed method
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) Set(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (b1 bool, err error)) *SubscriptionRepositoryMock {
	if mmIsSubscribed.defaultExpectation != nil {
		mmIsSubscribed.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.IsSubscribed method")
	}

	if len(mmIsSubscribed.expectations) > 0 {
		mmIsSubscribed.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.IsSubscribed method")
	}

	mmIsSubscribed.mock.funcIsSubscribed = f
	return mmIsSubscribed.mock
}

// When sets expectation for the SubscriptionRepository.IsSubscribed which will trigger the result defined by the following
// Then helper
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) When(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *SubscriptionRepositoryMockIsSubscribedExpectation {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("SubscriptionRepositoryMock.IsSubscribed mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockIsSubscribedExpectation{
		mock:   mmIsSubscribed.mock,
		params: &SubscriptionRepositoryMockIsSubscribedParams{ctx, subscriber, author},
	}
	mmIsSubscribed.expectations = append(mmIsSubscribed.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.IsSubscribed return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockIsSubscribedExpectation) Then(b1 bool, err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockIsSubscribedResults{b1, err}
	return e.mock
}

// IsSubscribed implements ports.SubscriptionRepository
func (mmIsSubscribed *SubscriptionRepositoryMock) IsSubscribed(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsSubscribed.beforeIsSubscribedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSubscribed.afterIsSubscribedCounter, 1)

	if mmIsSubscribed.inspectFuncIsSubscribed != nil {
		mmIsSubscribed.inspectFuncIsSubscribed(ctx, subscriber, author)
	}

	mm_params := &SubscriptionRepositoryMockIsSubscribedParams{ctx, subscriber, author}

	// Record call args
	mmIsSubscribed.IsSubscribedMock.mutex.Lock()
	mmIsSubscribed.IsSubscribedMock.callArgs = append(mmIsSubscribed.IsSubscribedMock.callArgs, mm_params)
	mmIsSubscribed.IsSubscribedMock.mutex.Unlock()

	for _, e := range mmIsSubscribed.IsSubscribedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsSubscribed.IsSubscribedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSubscribed.IsSubscribedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsSubscribed.IsSubscribedMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockIsSubscribedParams{ctx, subscriber, author}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsSubscribed.t.Errorf("SubscriptionRepositoryMock.IsSubscribed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsSubscribed.IsSubscribedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsSubscribed.t.Fatal("No results are set for the SubscriptionRepositoryMock.IsSubscribed")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsSubscribed.funcIsSubscribed != nil {
		return mmIsSubscribed.funcIsSubscribed(ctx, subscriber, author)
	}
	mmIsSubscribed.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.IsSubscribed. %v %v %v", ctx, subscriber, author)
	return
}

// IsSubscribedAfterCounter returns a count of finished SubscriptionRepositoryMock.IsSubscribed invocations
func (mmIsSubscribed *SubscriptionRepositoryMock) IsSubscribedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSubscribed.afterIsSubscribedCounter)
}

// IsSubscribedBeforeCounter returns a count of SubscriptionRepositoryMock.IsSubscribed invocations
func (mmIsSubscribed *SubscriptionRepositoryMock) IsSubscribedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSubscribed.beforeIsSubscribedCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.IsSubscribed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSubscribed *mSubscriptionRepositoryMockIsSubscribed) Calls() []*SubscriptionRepositoryMockIsSubscribedParams {
	mmIsSubscribed.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockIsSubscribedParams, len(mmIsSubscribed.callArgs))
	copy(argCopy, mmIsSubscribed.callArgs)

	mmIsSubscribed.mutex.RUnlock()

	return argCopy
}

// MinimockIsSubscribedDone returns true if the count of the IsSubscribed invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockIsSubscribedDone() bool {
	for _, e := range m.IsSubscribedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSubscribedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSubscribed != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsSubscribedInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockIsSubscribedInspect() {
	for _, e := range m.IsSubscribedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.IsSubscribed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSubscribedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		if m.IsSubscribedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.IsSubscribed")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.IsSubscribed with params: %#v", *m.IsSubscribedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSubscribed != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.IsSubscribed")
	}
}

type mSubscriptionRepositoryMockSubscribe struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockSubscribeExpectation
	expectations       []*SubscriptionRepositoryMockSubscribeExpectation

	callArgs []*SubscriptionRepositoryMockSubscribeParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockSubscribeExpectation specifies expectation struct of the SubscriptionRepository.Subscribe
type SubscriptionRepositoryMockSubscribeExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockSubscribeParams
	results *SubscriptionRepositoryMockSubscribeResults
	Counter uint64
}

// SubscriptionRepositoryMockSubscribeParams contains parameters of the SubscriptionRepository.Subscribe
type SubscriptionRepositoryMockSubscribeParams struct {
	ctx        context.Context
	subscriber uuid.UUID
	author     uuid.UUID
}

// SubscriptionRepositoryMockSubscribeResults contains results of the SubscriptionRepository.Subscribe
type SubscriptionRepositoryMockSubscribeResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Subscribe
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) Expect(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *mSubscriptionRepositoryMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &SubscriptionRepositoryMockSubscribeExpectation{}
	}

	mmSubscribe.defaultExpectation.params = &SubscriptionRepositoryMockSubscribeParams{ctx, subscriber, author}
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Subscribe
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) Inspect(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)) *mSubscriptionRepositoryMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by SubscriptionRepository.Subscribe
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) Return(err error) *SubscriptionRepositoryMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &SubscriptionRepositoryMockSubscribeExpectation{mock: mmSubscribe.mock}
	}
	mmSubscribe.defaultExpectation.results = &SubscriptionRepositoryMockSubscribeResults{err}
	return mmSubscribe.mock
}

// Set uses given function f to mock the SubscriptionRepository.Subscribe method
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) Set(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error)) *SubscriptionRepositoryMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	return mmSubscribe.mock
}

// When sets expectation for the SubscriptionRepository.Subscribe which will trigger the result defined by the following
// Then helper
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) When(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *SubscriptionRepositoryMockSubscribeExpectation {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Subscribe mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockSubscribeExpectation{
		mock:   mmSubscribe.mock,
		params: &SubscriptionRepositoryMockSubscribeParams{ctx, subscriber, author},
	}
	mmSubscribe.expectations = append(mmSubscribe.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Subscribe return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockSubscribeExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockSubscribeResults{err}
	return e.mock
}

// Subscribe implements ports.SubscriptionRepository
func (mmSubscribe *SubscriptionRepositoryMock) Subscribe(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(ctx, subscriber, author)
	}

	mm_params := &SubscriptionRepositoryMockSubscribeParams{ctx, subscriber, author}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockSubscribeParams{ctx, subscriber, author}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("SubscriptionRepositoryMock.Subscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribe.SubscribeMock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribe.t.Fatal("No results are set for the SubscriptionRepositoryMock.Subscribe")
		}
		return (*mm_results).err
	}
	if mmSubscribe.funcSubscribe != nil {
		return mmSubscribe.funcSubscribe(ctx, subscriber, author)
	}
	mmSubscribe.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Subscribe. %v %v %v", ctx, subscriber, author)
	return
}

// SubscribeAfterCounter returns a count of finished SubscriptionRepositoryMock.Subscribe invocations
func (mmSubscribe *SubscriptionRepositoryMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of SubscriptionRepositoryMock.Subscribe invocations
func (mmSubscribe *SubscriptionRepositoryMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mSubscriptionRepositoryMockSubscribe) Calls() []*SubscriptionRepositoryMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockSubscribeDone() bool {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Subscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Subscribe")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Subscribe with params: %#v", *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Subscribe")
	}
}

type mSubscriptionRepositoryMockUnsubscribe struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockUnsubscribeExpectation
	expectations       []*SubscriptionRepositoryMockUnsubscribeExpectation

	callArgs []*SubscriptionRepositoryMockUnsubscribeParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockUnsubscribeExpectation specifies expectation struct of the SubscriptionRepository.Unsubscribe
type SubscriptionRepositoryMockUnsubscribeExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockUnsubscribeParams
	results *SubscriptionRepositoryMockUnsubscribeResults
	Counter uint64
}

// SubscriptionRepositoryMockUnsubscribeParams contains parameters of the SubscriptionRepository.Unsubscribe
type SubscriptionRepositoryMockUnsubscribeParams struct {
	ctx        context.Context
	subscriber uuid.UUID
	author     uuid.UUID
}

// SubscriptionRepositoryMockUnsubscribeResults contains results of the SubscriptionRepository.Unsubscribe
type SubscriptionRepositoryMockUnsubscribeResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Unsubscribe
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) Expect(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *mSubscriptionRepositoryMockUnsubscribe {
	if mmUnsubscribe.mock.funcUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Unsubscribe mock is already set by Set")
	}

	if mmUnsubscribe.defaultExpectation == nil {
		mmUnsubscribe.defaultExpectation = &SubscriptionRepositoryMockUnsubscribeExpectation{}
	}

	mmUnsubscribe.defaultExpectation.params = &SubscriptionRepositoryMockUnsubscribeParams{ctx, subscriber, author}
	for _, e := range mmUnsubscribe.expectations {
		if minimock.Equal(e.params, mmUnsubscribe.defaultExpectation.params) {
			mmUnsubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnsubscribe.defaultExpectation.params)
		}
	}

	return mmUnsubscribe
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Unsubscribe
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) Inspect(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID)) *mSubscriptionRepositoryMockUnsubscribe {
	if mmUnsubscribe.mock.inspectFuncUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Unsubscribe")
	}

	mmUnsubscribe.mock.inspectFuncUnsubscribe = f

	return mmUnsubscribe
}

// Return sets up results that will be returned by SubscriptionRepository.Unsubscribe
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) Return(err error) *SubscriptionRepositoryMock {
	if mmUnsubscribe.mock.funcUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Unsubscribe mock is already set by Set")
	}

	if mmUnsubscribe.defaultExpectation == nil {
		mmUnsubscribe.defaultExpectation = &SubscriptionRepositoryMockUnsubscribeExpectation{mock: mmUnsubscribe.mock}
	}
	mmUnsubscribe.defaultExpectation.results = &SubscriptionRepositoryMockUnsubscribeResults{err}
	return mmUnsubscribe.mock
}

// Set uses given function f to mock the SubscriptionRepository.Unsubscribe method
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) Set(f func(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error)) *SubscriptionRepositoryMock {
	if mmUnsubscribe.defaultExpectation != nil {
		mmUnsubscribe.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Unsubscribe method")
	}

	if len(mmUnsubscribe.expectations) > 0 {
		mmUnsubscribe.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Unsubscribe method")
	}

	mmUnsubscribe.mock.funcUnsubscribe = f
	return mmUnsubscribe.mock
}

// When sets expectation for the SubscriptionRepository.Unsubscribe which will trigger the result defined by the following
// Then helper
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) When(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) *SubscriptionRepositoryMockUnsubscribeExpectation {
	if mmUnsubscribe.mock.funcUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("SubscriptionRepositoryMock.Unsubscribe mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockUnsubscribeExpectation{
		mock:   mmUnsubscribe.mock,
		params: &SubscriptionRepositoryMockUnsubscribeParams{ctx, subscriber, author},
	}
	mmUnsubscribe.expectations = append(mmUnsubscribe.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Unsubscribe return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockUnsubscribeExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockUnsubscribeResults{err}
	return e.mock
}

// Unsubscribe implements ports.SubscriptionRepository
func (mmUnsubscribe *SubscriptionRepositoryMock) Unsubscribe(ctx context.Context, subscriber uuid.UUID, author uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmUnsubscribe.beforeUnsubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmUnsubscribe.afterUnsubscribeCounter, 1)

	if mmUnsubscribe.inspectFuncUnsubscribe != nil {
		mmUnsubscribe.inspectFuncUnsubscribe(ctx, subscriber, author)
	}

	mm_params := &SubscriptionRepositoryMockUnsubscribeParams{ctx, subscriber, author}

	// Record call args
	mmUnsubscribe.UnsubscribeMock.mutex.Lock()
	mmUnsubscribe.UnsubscribeMock.callArgs = append(mmUnsubscribe.UnsubscribeMock.callArgs, mm_params)
	mmUnsubscribe.UnsubscribeMock.mutex.Unlock()

	for _, e := range mmUnsubscribe.UnsubscribeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnsubscribe.UnsubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnsubscribe.UnsubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmUnsubscribe.UnsubscribeMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockUnsubscribeParams{ctx, subscriber, author}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnsubscribe.t.Errorf("SubscriptionRepositoryMock.Unsubscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnsubscribe.UnsubscribeMock.defaultExpectation.results
		if mm_results == nil {
			mmUnsubscribe.t.Fatal("No results are set for the SubscriptionRepositoryMock.Unsubscribe")
		}
		return (*mm_results).err
	}
	if mmUnsubscribe.funcUnsubscribe != nil {
		return mmUnsubscribe.funcUnsubscribe(ctx, subscriber, author)
	}
	mmUnsubscribe.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Unsubscribe. %v %v %v", ctx, subscriber, author)
	return
}

// UnsubscribeAfterCounter returns a count of finished SubscriptionRepositoryMock.Unsubscribe invocations
func (mmUnsubscribe *SubscriptionRepositoryMock) UnsubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribe.afterUnsubscribeCounter)
}

// UnsubscribeBeforeCounter returns a count of SubscriptionRepositoryMock.Unsubscribe invocations
func (mmUnsubscribe *SubscriptionRepositoryMock) UnsubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribe.beforeUnsubscribeCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Unsubscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnsubscribe *mSubscriptionRepositoryMockUnsubscribe) Calls() []*SubscriptionRepositoryMockUnsubscribeParams {
	mmUnsubscribe.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockUnsubscribeParams, len(mmUnsubscribe.callArgs))
	copy(argCopy, mmUnsubscribe.callArgs)

	mmUnsubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockUnsubscribeDone returns true if the count of the Unsubscribe invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockUnsubscribeDone() bool {
	for _, e := range m.UnsubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribe != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnsubscribeInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockUnsubscribeInspect() {
	for _, e := range m.UnsubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Unsubscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		if m.UnsubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Unsubscribe")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Unsubscribe with params: %#v", *m.UnsubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribe != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Unsubscribe")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIsSubscribedInspect()

		m.MinimockSubscribeInspect()

		m.MinimockUnsubscribeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubscriptionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsSubscribedDone() &&
		m.MinimockSubscribeDone() &&
		m.MinimockUnsubscribeDone()
}
