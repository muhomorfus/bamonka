package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/ports.TeamRepository -o ./internal/mocks/team_repository_mock.go -n TeamRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// TeamRepositoryMock implements ports.TeamRepository
type TeamRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, team models.Team) (tp1 *models.Team, err error)
	inspectFuncCreate   func(ctx context.Context, team models.Team)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mTeamRepositoryMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mTeamRepositoryMockDelete

	funcGet          func(ctx context.Context, id uuid.UUID) (tp1 *models.Team, err error)
	inspectFuncGet   func(ctx context.Context, id uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mTeamRepositoryMockGet

	funcGetAll          func(ctx context.Context) (ta1 []models.Team, err error)
	inspectFuncGetAll   func(ctx context.Context)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mTeamRepositoryMockGetAll

	funcListSimilarByName          func(ctx context.Context, substr string) (ta1 []models.Team, err error)
	inspectFuncListSimilarByName   func(ctx context.Context, substr string)
	afterListSimilarByNameCounter  uint64
	beforeListSimilarByNameCounter uint64
	ListSimilarByNameMock          mTeamRepositoryMockListSimilarByName

	funcUpdate          func(ctx context.Context, team models.Team) (err error)
	inspectFuncUpdate   func(ctx context.Context, team models.Team)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mTeamRepositoryMockUpdate
}

// NewTeamRepositoryMock returns a mock for ports.TeamRepository
func NewTeamRepositoryMock(t minimock.Tester) *TeamRepositoryMock {
	m := &TeamRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mTeamRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*TeamRepositoryMockCreateParams{}

	m.DeleteMock = mTeamRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*TeamRepositoryMockDeleteParams{}

	m.GetMock = mTeamRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*TeamRepositoryMockGetParams{}

	m.GetAllMock = mTeamRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*TeamRepositoryMockGetAllParams{}

	m.ListSimilarByNameMock = mTeamRepositoryMockListSimilarByName{mock: m}
	m.ListSimilarByNameMock.callArgs = []*TeamRepositoryMockListSimilarByNameParams{}

	m.UpdateMock = mTeamRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*TeamRepositoryMockUpdateParams{}

	return m
}

type mTeamRepositoryMockCreate struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockCreateExpectation
	expectations       []*TeamRepositoryMockCreateExpectation

	callArgs []*TeamRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockCreateExpectation specifies expectation struct of the TeamRepository.Create
type TeamRepositoryMockCreateExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockCreateParams
	results *TeamRepositoryMockCreateResults
	Counter uint64
}

// TeamRepositoryMockCreateParams contains parameters of the TeamRepository.Create
type TeamRepositoryMockCreateParams struct {
	ctx  context.Context
	team models.Team
}

// TeamRepositoryMockCreateResults contains results of the TeamRepository.Create
type TeamRepositoryMockCreateResults struct {
	tp1 *models.Team
	err error
}

// Expect sets up expected params for TeamRepository.Create
func (mmCreate *mTeamRepositoryMockCreate) Expect(ctx context.Context, team models.Team) *mTeamRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TeamRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TeamRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &TeamRepositoryMockCreateParams{ctx, team}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.Create
func (mmCreate *mTeamRepositoryMockCreate) Inspect(f func(ctx context.Context, team models.Team)) *mTeamRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by TeamRepository.Create
func (mmCreate *mTeamRepositoryMockCreate) Return(tp1 *models.Team, err error) *TeamRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TeamRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TeamRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &TeamRepositoryMockCreateResults{tp1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the TeamRepository.Create method
func (mmCreate *mTeamRepositoryMockCreate) Set(f func(ctx context.Context, team models.Team) (tp1 *models.Team, err error)) *TeamRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the TeamRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the TeamRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the TeamRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mTeamRepositoryMockCreate) When(ctx context.Context, team models.Team) *TeamRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TeamRepositoryMock.Create mock is already set by Set")
	}

	expectation := &TeamRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &TeamRepositoryMockCreateParams{ctx, team},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.Create return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockCreateExpectation) Then(tp1 *models.Team, err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockCreateResults{tp1, err}
	return e.mock
}

// Create implements ports.TeamRepository
func (mmCreate *TeamRepositoryMock) Create(ctx context.Context, team models.Team) (tp1 *models.Team, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, team)
	}

	mm_params := &TeamRepositoryMockCreateParams{ctx, team}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := TeamRepositoryMockCreateParams{ctx, team}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("TeamRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the TeamRepositoryMock.Create")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, team)
	}
	mmCreate.t.Fatalf("Unexpected call to TeamRepositoryMock.Create. %v %v", ctx, team)
	return
}

// CreateAfterCounter returns a count of finished TeamRepositoryMock.Create invocations
func (mmCreate *TeamRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of TeamRepositoryMock.Create invocations
func (mmCreate *TeamRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mTeamRepositoryMockCreate) Calls() []*TeamRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.Create")
	}
}

type mTeamRepositoryMockDelete struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockDeleteExpectation
	expectations       []*TeamRepositoryMockDeleteExpectation

	callArgs []*TeamRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockDeleteExpectation specifies expectation struct of the TeamRepository.Delete
type TeamRepositoryMockDeleteExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockDeleteParams
	results *TeamRepositoryMockDeleteResults
	Counter uint64
}

// TeamRepositoryMockDeleteParams contains parameters of the TeamRepository.Delete
type TeamRepositoryMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// TeamRepositoryMockDeleteResults contains results of the TeamRepository.Delete
type TeamRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for TeamRepository.Delete
func (mmDelete *mTeamRepositoryMockDelete) Expect(ctx context.Context, id uuid.UUID) *mTeamRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("TeamRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &TeamRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &TeamRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.Delete
func (mmDelete *mTeamRepositoryMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mTeamRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by TeamRepository.Delete
func (mmDelete *mTeamRepositoryMockDelete) Return(err error) *TeamRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("TeamRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &TeamRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &TeamRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the TeamRepository.Delete method
func (mmDelete *mTeamRepositoryMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *TeamRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the TeamRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the TeamRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the TeamRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mTeamRepositoryMockDelete) When(ctx context.Context, id uuid.UUID) *TeamRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("TeamRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &TeamRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &TeamRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.Delete return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockDeleteExpectation) Then(err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements ports.TeamRepository
func (mmDelete *TeamRepositoryMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := &TeamRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := TeamRepositoryMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("TeamRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the TeamRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to TeamRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished TeamRepositoryMock.Delete invocations
func (mmDelete *TeamRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of TeamRepositoryMock.Delete invocations
func (mmDelete *TeamRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mTeamRepositoryMockDelete) Calls() []*TeamRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.Delete")
	}
}

type mTeamRepositoryMockGet struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockGetExpectation
	expectations       []*TeamRepositoryMockGetExpectation

	callArgs []*TeamRepositoryMockGetParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockGetExpectation specifies expectation struct of the TeamRepository.Get
type TeamRepositoryMockGetExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockGetParams
	results *TeamRepositoryMockGetResults
	Counter uint64
}

// TeamRepositoryMockGetParams contains parameters of the TeamRepository.Get
type TeamRepositoryMockGetParams struct {
	ctx context.Context
	id  uuid.UUID
}

// TeamRepositoryMockGetResults contains results of the TeamRepository.Get
type TeamRepositoryMockGetResults struct {
	tp1 *models.Team
	err error
}

// Expect sets up expected params for TeamRepository.Get
func (mmGet *mTeamRepositoryMockGet) Expect(ctx context.Context, id uuid.UUID) *mTeamRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TeamRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TeamRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &TeamRepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.Get
func (mmGet *mTeamRepositoryMockGet) Inspect(f func(ctx context.Context, id uuid.UUID)) *mTeamRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by TeamRepository.Get
func (mmGet *mTeamRepositoryMockGet) Return(tp1 *models.Team, err error) *TeamRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TeamRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TeamRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &TeamRepositoryMockGetResults{tp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the TeamRepository.Get method
func (mmGet *mTeamRepositoryMockGet) Set(f func(ctx context.Context, id uuid.UUID) (tp1 *models.Team, err error)) *TeamRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the TeamRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the TeamRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the TeamRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mTeamRepositoryMockGet) When(ctx context.Context, id uuid.UUID) *TeamRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TeamRepositoryMock.Get mock is already set by Set")
	}

	expectation := &TeamRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &TeamRepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.Get return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockGetExpectation) Then(tp1 *models.Team, err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockGetResults{tp1, err}
	return e.mock
}

// Get implements ports.TeamRepository
func (mmGet *TeamRepositoryMock) Get(ctx context.Context, id uuid.UUID) (tp1 *models.Team, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := &TeamRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := TeamRepositoryMockGetParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("TeamRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the TeamRepositoryMock.Get")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to TeamRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished TeamRepositoryMock.Get invocations
func (mmGet *TeamRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of TeamRepositoryMock.Get invocations
func (mmGet *TeamRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mTeamRepositoryMockGet) Calls() []*TeamRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.Get")
	}
}

type mTeamRepositoryMockGetAll struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockGetAllExpectation
	expectations       []*TeamRepositoryMockGetAllExpectation

	callArgs []*TeamRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockGetAllExpectation specifies expectation struct of the TeamRepository.GetAll
type TeamRepositoryMockGetAllExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockGetAllParams
	results *TeamRepositoryMockGetAllResults
	Counter uint64
}

// TeamRepositoryMockGetAllParams contains parameters of the TeamRepository.GetAll
type TeamRepositoryMockGetAllParams struct {
	ctx context.Context
}

// TeamRepositoryMockGetAllResults contains results of the TeamRepository.GetAll
type TeamRepositoryMockGetAllResults struct {
	ta1 []models.Team
	err error
}

// Expect sets up expected params for TeamRepository.GetAll
func (mmGetAll *mTeamRepositoryMockGetAll) Expect(ctx context.Context) *mTeamRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("TeamRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &TeamRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &TeamRepositoryMockGetAllParams{ctx}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.GetAll
func (mmGetAll *mTeamRepositoryMockGetAll) Inspect(f func(ctx context.Context)) *mTeamRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by TeamRepository.GetAll
func (mmGetAll *mTeamRepositoryMockGetAll) Return(ta1 []models.Team, err error) *TeamRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("TeamRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &TeamRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &TeamRepositoryMockGetAllResults{ta1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the TeamRepository.GetAll method
func (mmGetAll *mTeamRepositoryMockGetAll) Set(f func(ctx context.Context) (ta1 []models.Team, err error)) *TeamRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the TeamRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the TeamRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the TeamRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mTeamRepositoryMockGetAll) When(ctx context.Context) *TeamRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("TeamRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &TeamRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &TeamRepositoryMockGetAllParams{ctx},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockGetAllExpectation) Then(ta1 []models.Team, err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockGetAllResults{ta1, err}
	return e.mock
}

// GetAll implements ports.TeamRepository
func (mmGetAll *TeamRepositoryMock) GetAll(ctx context.Context) (ta1 []models.Team, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx)
	}

	mm_params := &TeamRepositoryMockGetAllParams{ctx}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := TeamRepositoryMockGetAllParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("TeamRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the TeamRepositoryMock.GetAll")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx)
	}
	mmGetAll.t.Fatalf("Unexpected call to TeamRepositoryMock.GetAll. %v", ctx)
	return
}

// GetAllAfterCounter returns a count of finished TeamRepositoryMock.GetAll invocations
func (mmGetAll *TeamRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of TeamRepositoryMock.GetAll invocations
func (mmGetAll *TeamRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mTeamRepositoryMockGetAll) Calls() []*TeamRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.GetAll")
	}
}

type mTeamRepositoryMockListSimilarByName struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockListSimilarByNameExpectation
	expectations       []*TeamRepositoryMockListSimilarByNameExpectation

	callArgs []*TeamRepositoryMockListSimilarByNameParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockListSimilarByNameExpectation specifies expectation struct of the TeamRepository.ListSimilarByName
type TeamRepositoryMockListSimilarByNameExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockListSimilarByNameParams
	results *TeamRepositoryMockListSimilarByNameResults
	Counter uint64
}

// TeamRepositoryMockListSimilarByNameParams contains parameters of the TeamRepository.ListSimilarByName
type TeamRepositoryMockListSimilarByNameParams struct {
	ctx    context.Context
	substr string
}

// TeamRepositoryMockListSimilarByNameResults contains results of the TeamRepository.ListSimilarByName
type TeamRepositoryMockListSimilarByNameResults struct {
	ta1 []models.Team
	err error
}

// Expect sets up expected params for TeamRepository.ListSimilarByName
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) Expect(ctx context.Context, substr string) *mTeamRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("TeamRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &TeamRepositoryMockListSimilarByNameExpectation{}
	}

	mmListSimilarByName.defaultExpectation.params = &TeamRepositoryMockListSimilarByNameParams{ctx, substr}
	for _, e := range mmListSimilarByName.expectations {
		if minimock.Equal(e.params, mmListSimilarByName.defaultExpectation.params) {
			mmListSimilarByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSimilarByName.defaultExpectation.params)
		}
	}

	return mmListSimilarByName
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.ListSimilarByName
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) Inspect(f func(ctx context.Context, substr string)) *mTeamRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.ListSimilarByName")
	}

	mmListSimilarByName.mock.inspectFuncListSimilarByName = f

	return mmListSimilarByName
}

// Return sets up results that will be returned by TeamRepository.ListSimilarByName
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) Return(ta1 []models.Team, err error) *TeamRepositoryMock {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("TeamRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &TeamRepositoryMockListSimilarByNameExpectation{mock: mmListSimilarByName.mock}
	}
	mmListSimilarByName.defaultExpectation.results = &TeamRepositoryMockListSimilarByNameResults{ta1, err}
	return mmListSimilarByName.mock
}

// Set uses given function f to mock the TeamRepository.ListSimilarByName method
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) Set(f func(ctx context.Context, substr string) (ta1 []models.Team, err error)) *TeamRepositoryMock {
	if mmListSimilarByName.defaultExpectation != nil {
		mmListSimilarByName.mock.t.Fatalf("Default expectation is already set for the TeamRepository.ListSimilarByName method")
	}

	if len(mmListSimilarByName.expectations) > 0 {
		mmListSimilarByName.mock.t.Fatalf("Some expectations are already set for the TeamRepository.ListSimilarByName method")
	}

	mmListSimilarByName.mock.funcListSimilarByName = f
	return mmListSimilarByName.mock
}

// When sets expectation for the TeamRepository.ListSimilarByName which will trigger the result defined by the following
// Then helper
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) When(ctx context.Context, substr string) *TeamRepositoryMockListSimilarByNameExpectation {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("TeamRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	expectation := &TeamRepositoryMockListSimilarByNameExpectation{
		mock:   mmListSimilarByName.mock,
		params: &TeamRepositoryMockListSimilarByNameParams{ctx, substr},
	}
	mmListSimilarByName.expectations = append(mmListSimilarByName.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.ListSimilarByName return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockListSimilarByNameExpectation) Then(ta1 []models.Team, err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockListSimilarByNameResults{ta1, err}
	return e.mock
}

// ListSimilarByName implements ports.TeamRepository
func (mmListSimilarByName *TeamRepositoryMock) ListSimilarByName(ctx context.Context, substr string) (ta1 []models.Team, err error) {
	mm_atomic.AddUint64(&mmListSimilarByName.beforeListSimilarByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmListSimilarByName.afterListSimilarByNameCounter, 1)

	if mmListSimilarByName.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.inspectFuncListSimilarByName(ctx, substr)
	}

	mm_params := &TeamRepositoryMockListSimilarByNameParams{ctx, substr}

	// Record call args
	mmListSimilarByName.ListSimilarByNameMock.mutex.Lock()
	mmListSimilarByName.ListSimilarByNameMock.callArgs = append(mmListSimilarByName.ListSimilarByNameMock.callArgs, mm_params)
	mmListSimilarByName.ListSimilarByNameMock.mutex.Unlock()

	for _, e := range mmListSimilarByName.ListSimilarByNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListSimilarByName.ListSimilarByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.params
		mm_got := TeamRepositoryMockListSimilarByNameParams{ctx, substr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSimilarByName.t.Errorf("TeamRepositoryMock.ListSimilarByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmListSimilarByName.t.Fatal("No results are set for the TeamRepositoryMock.ListSimilarByName")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListSimilarByName.funcListSimilarByName != nil {
		return mmListSimilarByName.funcListSimilarByName(ctx, substr)
	}
	mmListSimilarByName.t.Fatalf("Unexpected call to TeamRepositoryMock.ListSimilarByName. %v %v", ctx, substr)
	return
}

// ListSimilarByNameAfterCounter returns a count of finished TeamRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *TeamRepositoryMock) ListSimilarByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.afterListSimilarByNameCounter)
}

// ListSimilarByNameBeforeCounter returns a count of TeamRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *TeamRepositoryMock) ListSimilarByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.beforeListSimilarByNameCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.ListSimilarByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSimilarByName *mTeamRepositoryMockListSimilarByName) Calls() []*TeamRepositoryMockListSimilarByNameParams {
	mmListSimilarByName.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockListSimilarByNameParams, len(mmListSimilarByName.callArgs))
	copy(argCopy, mmListSimilarByName.callArgs)

	mmListSimilarByName.mutex.RUnlock()

	return argCopy
}

// MinimockListSimilarByNameDone returns true if the count of the ListSimilarByName invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockListSimilarByNameDone() bool {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSimilarByNameInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockListSimilarByNameInspect() {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.ListSimilarByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		if m.ListSimilarByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.ListSimilarByName")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.ListSimilarByName with params: %#v", *m.ListSimilarByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.ListSimilarByName")
	}
}

type mTeamRepositoryMockUpdate struct {
	mock               *TeamRepositoryMock
	defaultExpectation *TeamRepositoryMockUpdateExpectation
	expectations       []*TeamRepositoryMockUpdateExpectation

	callArgs []*TeamRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// TeamRepositoryMockUpdateExpectation specifies expectation struct of the TeamRepository.Update
type TeamRepositoryMockUpdateExpectation struct {
	mock    *TeamRepositoryMock
	params  *TeamRepositoryMockUpdateParams
	results *TeamRepositoryMockUpdateResults
	Counter uint64
}

// TeamRepositoryMockUpdateParams contains parameters of the TeamRepository.Update
type TeamRepositoryMockUpdateParams struct {
	ctx  context.Context
	team models.Team
}

// TeamRepositoryMockUpdateResults contains results of the TeamRepository.Update
type TeamRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for TeamRepository.Update
func (mmUpdate *mTeamRepositoryMockUpdate) Expect(ctx context.Context, team models.Team) *mTeamRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TeamRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TeamRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &TeamRepositoryMockUpdateParams{ctx, team}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the TeamRepository.Update
func (mmUpdate *mTeamRepositoryMockUpdate) Inspect(f func(ctx context.Context, team models.Team)) *mTeamRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for TeamRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by TeamRepository.Update
func (mmUpdate *mTeamRepositoryMockUpdate) Return(err error) *TeamRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TeamRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TeamRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &TeamRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the TeamRepository.Update method
func (mmUpdate *mTeamRepositoryMockUpdate) Set(f func(ctx context.Context, team models.Team) (err error)) *TeamRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the TeamRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the TeamRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the TeamRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mTeamRepositoryMockUpdate) When(ctx context.Context, team models.Team) *TeamRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TeamRepositoryMock.Update mock is already set by Set")
	}

	expectation := &TeamRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &TeamRepositoryMockUpdateParams{ctx, team},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up TeamRepository.Update return parameters for the expectation previously defined by the When method
func (e *TeamRepositoryMockUpdateExpectation) Then(err error) *TeamRepositoryMock {
	e.results = &TeamRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements ports.TeamRepository
func (mmUpdate *TeamRepositoryMock) Update(ctx context.Context, team models.Team) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, team)
	}

	mm_params := &TeamRepositoryMockUpdateParams{ctx, team}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := TeamRepositoryMockUpdateParams{ctx, team}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("TeamRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the TeamRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, team)
	}
	mmUpdate.t.Fatalf("Unexpected call to TeamRepositoryMock.Update. %v %v", ctx, team)
	return
}

// UpdateAfterCounter returns a count of finished TeamRepositoryMock.Update invocations
func (mmUpdate *TeamRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of TeamRepositoryMock.Update invocations
func (mmUpdate *TeamRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to TeamRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTeamRepositoryMockUpdate) Calls() []*TeamRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*TeamRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TeamRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TeamRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TeamRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TeamRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to TeamRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to TeamRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TeamRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()

		m.MinimockListSimilarByNameInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TeamRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TeamRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockListSimilarByNameDone() &&
		m.MinimockUpdateDone()
}
