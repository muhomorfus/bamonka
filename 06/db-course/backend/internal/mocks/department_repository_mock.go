package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/ports.DepartmentRepository -o ./internal/mocks/department_repository_mock.go -n DepartmentRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/iu7-kostritsky/iu7-db-course-project-2023-knyazhevaleksey-backend/internal/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// DepartmentRepositoryMock implements ports.DepartmentRepository
type DepartmentRepositoryMock struct {
	t minimock.Tester

	funcBreadcrumbs          func(ctx context.Context, id uuid.UUID) (da1 []models.DepartmentShort, err error)
	inspectFuncBreadcrumbs   func(ctx context.Context, id uuid.UUID)
	afterBreadcrumbsCounter  uint64
	beforeBreadcrumbsCounter uint64
	BreadcrumbsMock          mDepartmentRepositoryMockBreadcrumbs

	funcChildren          func(ctx context.Context, id uuid.UUID) (da1 []models.Department, err error)
	inspectFuncChildren   func(ctx context.Context, id uuid.UUID)
	afterChildrenCounter  uint64
	beforeChildrenCounter uint64
	ChildrenMock          mDepartmentRepositoryMockChildren

	funcCreate          func(ctx context.Context, dep models.Department) (dp1 *models.Department, err error)
	inspectFuncCreate   func(ctx context.Context, dep models.Department)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mDepartmentRepositoryMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mDepartmentRepositoryMockDelete

	funcGet          func(ctx context.Context, id uuid.UUID) (dp1 *models.Department, err error)
	inspectFuncGet   func(ctx context.Context, id uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mDepartmentRepositoryMockGet

	funcGetAll          func(ctx context.Context) (da1 []models.Department, err error)
	inspectFuncGetAll   func(ctx context.Context)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mDepartmentRepositoryMockGetAll

	funcListSimilarByName          func(ctx context.Context, substr string) (da1 []models.Department, err error)
	inspectFuncListSimilarByName   func(ctx context.Context, substr string)
	afterListSimilarByNameCounter  uint64
	beforeListSimilarByNameCounter uint64
	ListSimilarByNameMock          mDepartmentRepositoryMockListSimilarByName

	funcUpdate          func(ctx context.Context, dep models.Department) (err error)
	inspectFuncUpdate   func(ctx context.Context, dep models.Department)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mDepartmentRepositoryMockUpdate
}

// NewDepartmentRepositoryMock returns a mock for ports.DepartmentRepository
func NewDepartmentRepositoryMock(t minimock.Tester) *DepartmentRepositoryMock {
	m := &DepartmentRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BreadcrumbsMock = mDepartmentRepositoryMockBreadcrumbs{mock: m}
	m.BreadcrumbsMock.callArgs = []*DepartmentRepositoryMockBreadcrumbsParams{}

	m.ChildrenMock = mDepartmentRepositoryMockChildren{mock: m}
	m.ChildrenMock.callArgs = []*DepartmentRepositoryMockChildrenParams{}

	m.CreateMock = mDepartmentRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*DepartmentRepositoryMockCreateParams{}

	m.DeleteMock = mDepartmentRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*DepartmentRepositoryMockDeleteParams{}

	m.GetMock = mDepartmentRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*DepartmentRepositoryMockGetParams{}

	m.GetAllMock = mDepartmentRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*DepartmentRepositoryMockGetAllParams{}

	m.ListSimilarByNameMock = mDepartmentRepositoryMockListSimilarByName{mock: m}
	m.ListSimilarByNameMock.callArgs = []*DepartmentRepositoryMockListSimilarByNameParams{}

	m.UpdateMock = mDepartmentRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*DepartmentRepositoryMockUpdateParams{}

	return m
}

type mDepartmentRepositoryMockBreadcrumbs struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockBreadcrumbsExpectation
	expectations       []*DepartmentRepositoryMockBreadcrumbsExpectation

	callArgs []*DepartmentRepositoryMockBreadcrumbsParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockBreadcrumbsExpectation specifies expectation struct of the DepartmentRepository.Breadcrumbs
type DepartmentRepositoryMockBreadcrumbsExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockBreadcrumbsParams
	results *DepartmentRepositoryMockBreadcrumbsResults
	Counter uint64
}

// DepartmentRepositoryMockBreadcrumbsParams contains parameters of the DepartmentRepository.Breadcrumbs
type DepartmentRepositoryMockBreadcrumbsParams struct {
	ctx context.Context
	id  uuid.UUID
}

// DepartmentRepositoryMockBreadcrumbsResults contains results of the DepartmentRepository.Breadcrumbs
type DepartmentRepositoryMockBreadcrumbsResults struct {
	da1 []models.DepartmentShort
	err error
}

// Expect sets up expected params for DepartmentRepository.Breadcrumbs
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) Expect(ctx context.Context, id uuid.UUID) *mDepartmentRepositoryMockBreadcrumbs {
	if mmBreadcrumbs.mock.funcBreadcrumbs != nil {
		mmBreadcrumbs.mock.t.Fatalf("DepartmentRepositoryMock.Breadcrumbs mock is already set by Set")
	}

	if mmBreadcrumbs.defaultExpectation == nil {
		mmBreadcrumbs.defaultExpectation = &DepartmentRepositoryMockBreadcrumbsExpectation{}
	}

	mmBreadcrumbs.defaultExpectation.params = &DepartmentRepositoryMockBreadcrumbsParams{ctx, id}
	for _, e := range mmBreadcrumbs.expectations {
		if minimock.Equal(e.params, mmBreadcrumbs.defaultExpectation.params) {
			mmBreadcrumbs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBreadcrumbs.defaultExpectation.params)
		}
	}

	return mmBreadcrumbs
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Breadcrumbs
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) Inspect(f func(ctx context.Context, id uuid.UUID)) *mDepartmentRepositoryMockBreadcrumbs {
	if mmBreadcrumbs.mock.inspectFuncBreadcrumbs != nil {
		mmBreadcrumbs.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Breadcrumbs")
	}

	mmBreadcrumbs.mock.inspectFuncBreadcrumbs = f

	return mmBreadcrumbs
}

// Return sets up results that will be returned by DepartmentRepository.Breadcrumbs
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) Return(da1 []models.DepartmentShort, err error) *DepartmentRepositoryMock {
	if mmBreadcrumbs.mock.funcBreadcrumbs != nil {
		mmBreadcrumbs.mock.t.Fatalf("DepartmentRepositoryMock.Breadcrumbs mock is already set by Set")
	}

	if mmBreadcrumbs.defaultExpectation == nil {
		mmBreadcrumbs.defaultExpectation = &DepartmentRepositoryMockBreadcrumbsExpectation{mock: mmBreadcrumbs.mock}
	}
	mmBreadcrumbs.defaultExpectation.results = &DepartmentRepositoryMockBreadcrumbsResults{da1, err}
	return mmBreadcrumbs.mock
}

// Set uses given function f to mock the DepartmentRepository.Breadcrumbs method
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) Set(f func(ctx context.Context, id uuid.UUID) (da1 []models.DepartmentShort, err error)) *DepartmentRepositoryMock {
	if mmBreadcrumbs.defaultExpectation != nil {
		mmBreadcrumbs.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Breadcrumbs method")
	}

	if len(mmBreadcrumbs.expectations) > 0 {
		mmBreadcrumbs.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Breadcrumbs method")
	}

	mmBreadcrumbs.mock.funcBreadcrumbs = f
	return mmBreadcrumbs.mock
}

// When sets expectation for the DepartmentRepository.Breadcrumbs which will trigger the result defined by the following
// Then helper
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) When(ctx context.Context, id uuid.UUID) *DepartmentRepositoryMockBreadcrumbsExpectation {
	if mmBreadcrumbs.mock.funcBreadcrumbs != nil {
		mmBreadcrumbs.mock.t.Fatalf("DepartmentRepositoryMock.Breadcrumbs mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockBreadcrumbsExpectation{
		mock:   mmBreadcrumbs.mock,
		params: &DepartmentRepositoryMockBreadcrumbsParams{ctx, id},
	}
	mmBreadcrumbs.expectations = append(mmBreadcrumbs.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Breadcrumbs return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockBreadcrumbsExpectation) Then(da1 []models.DepartmentShort, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockBreadcrumbsResults{da1, err}
	return e.mock
}

// Breadcrumbs implements ports.DepartmentRepository
func (mmBreadcrumbs *DepartmentRepositoryMock) Breadcrumbs(ctx context.Context, id uuid.UUID) (da1 []models.DepartmentShort, err error) {
	mm_atomic.AddUint64(&mmBreadcrumbs.beforeBreadcrumbsCounter, 1)
	defer mm_atomic.AddUint64(&mmBreadcrumbs.afterBreadcrumbsCounter, 1)

	if mmBreadcrumbs.inspectFuncBreadcrumbs != nil {
		mmBreadcrumbs.inspectFuncBreadcrumbs(ctx, id)
	}

	mm_params := &DepartmentRepositoryMockBreadcrumbsParams{ctx, id}

	// Record call args
	mmBreadcrumbs.BreadcrumbsMock.mutex.Lock()
	mmBreadcrumbs.BreadcrumbsMock.callArgs = append(mmBreadcrumbs.BreadcrumbsMock.callArgs, mm_params)
	mmBreadcrumbs.BreadcrumbsMock.mutex.Unlock()

	for _, e := range mmBreadcrumbs.BreadcrumbsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmBreadcrumbs.BreadcrumbsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBreadcrumbs.BreadcrumbsMock.defaultExpectation.Counter, 1)
		mm_want := mmBreadcrumbs.BreadcrumbsMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockBreadcrumbsParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBreadcrumbs.t.Errorf("DepartmentRepositoryMock.Breadcrumbs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBreadcrumbs.BreadcrumbsMock.defaultExpectation.results
		if mm_results == nil {
			mmBreadcrumbs.t.Fatal("No results are set for the DepartmentRepositoryMock.Breadcrumbs")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmBreadcrumbs.funcBreadcrumbs != nil {
		return mmBreadcrumbs.funcBreadcrumbs(ctx, id)
	}
	mmBreadcrumbs.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Breadcrumbs. %v %v", ctx, id)
	return
}

// BreadcrumbsAfterCounter returns a count of finished DepartmentRepositoryMock.Breadcrumbs invocations
func (mmBreadcrumbs *DepartmentRepositoryMock) BreadcrumbsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBreadcrumbs.afterBreadcrumbsCounter)
}

// BreadcrumbsBeforeCounter returns a count of DepartmentRepositoryMock.Breadcrumbs invocations
func (mmBreadcrumbs *DepartmentRepositoryMock) BreadcrumbsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBreadcrumbs.beforeBreadcrumbsCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Breadcrumbs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBreadcrumbs *mDepartmentRepositoryMockBreadcrumbs) Calls() []*DepartmentRepositoryMockBreadcrumbsParams {
	mmBreadcrumbs.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockBreadcrumbsParams, len(mmBreadcrumbs.callArgs))
	copy(argCopy, mmBreadcrumbs.callArgs)

	mmBreadcrumbs.mutex.RUnlock()

	return argCopy
}

// MinimockBreadcrumbsDone returns true if the count of the Breadcrumbs invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockBreadcrumbsDone() bool {
	for _, e := range m.BreadcrumbsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BreadcrumbsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBreadcrumbsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBreadcrumbs != nil && mm_atomic.LoadUint64(&m.afterBreadcrumbsCounter) < 1 {
		return false
	}
	return true
}

// MinimockBreadcrumbsInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockBreadcrumbsInspect() {
	for _, e := range m.BreadcrumbsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Breadcrumbs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BreadcrumbsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBreadcrumbsCounter) < 1 {
		if m.BreadcrumbsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Breadcrumbs")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Breadcrumbs with params: %#v", *m.BreadcrumbsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBreadcrumbs != nil && mm_atomic.LoadUint64(&m.afterBreadcrumbsCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Breadcrumbs")
	}
}

type mDepartmentRepositoryMockChildren struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockChildrenExpectation
	expectations       []*DepartmentRepositoryMockChildrenExpectation

	callArgs []*DepartmentRepositoryMockChildrenParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockChildrenExpectation specifies expectation struct of the DepartmentRepository.Children
type DepartmentRepositoryMockChildrenExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockChildrenParams
	results *DepartmentRepositoryMockChildrenResults
	Counter uint64
}

// DepartmentRepositoryMockChildrenParams contains parameters of the DepartmentRepository.Children
type DepartmentRepositoryMockChildrenParams struct {
	ctx context.Context
	id  uuid.UUID
}

// DepartmentRepositoryMockChildrenResults contains results of the DepartmentRepository.Children
type DepartmentRepositoryMockChildrenResults struct {
	da1 []models.Department
	err error
}

// Expect sets up expected params for DepartmentRepository.Children
func (mmChildren *mDepartmentRepositoryMockChildren) Expect(ctx context.Context, id uuid.UUID) *mDepartmentRepositoryMockChildren {
	if mmChildren.mock.funcChildren != nil {
		mmChildren.mock.t.Fatalf("DepartmentRepositoryMock.Children mock is already set by Set")
	}

	if mmChildren.defaultExpectation == nil {
		mmChildren.defaultExpectation = &DepartmentRepositoryMockChildrenExpectation{}
	}

	mmChildren.defaultExpectation.params = &DepartmentRepositoryMockChildrenParams{ctx, id}
	for _, e := range mmChildren.expectations {
		if minimock.Equal(e.params, mmChildren.defaultExpectation.params) {
			mmChildren.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChildren.defaultExpectation.params)
		}
	}

	return mmChildren
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Children
func (mmChildren *mDepartmentRepositoryMockChildren) Inspect(f func(ctx context.Context, id uuid.UUID)) *mDepartmentRepositoryMockChildren {
	if mmChildren.mock.inspectFuncChildren != nil {
		mmChildren.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Children")
	}

	mmChildren.mock.inspectFuncChildren = f

	return mmChildren
}

// Return sets up results that will be returned by DepartmentRepository.Children
func (mmChildren *mDepartmentRepositoryMockChildren) Return(da1 []models.Department, err error) *DepartmentRepositoryMock {
	if mmChildren.mock.funcChildren != nil {
		mmChildren.mock.t.Fatalf("DepartmentRepositoryMock.Children mock is already set by Set")
	}

	if mmChildren.defaultExpectation == nil {
		mmChildren.defaultExpectation = &DepartmentRepositoryMockChildrenExpectation{mock: mmChildren.mock}
	}
	mmChildren.defaultExpectation.results = &DepartmentRepositoryMockChildrenResults{da1, err}
	return mmChildren.mock
}

// Set uses given function f to mock the DepartmentRepository.Children method
func (mmChildren *mDepartmentRepositoryMockChildren) Set(f func(ctx context.Context, id uuid.UUID) (da1 []models.Department, err error)) *DepartmentRepositoryMock {
	if mmChildren.defaultExpectation != nil {
		mmChildren.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Children method")
	}

	if len(mmChildren.expectations) > 0 {
		mmChildren.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Children method")
	}

	mmChildren.mock.funcChildren = f
	return mmChildren.mock
}

// When sets expectation for the DepartmentRepository.Children which will trigger the result defined by the following
// Then helper
func (mmChildren *mDepartmentRepositoryMockChildren) When(ctx context.Context, id uuid.UUID) *DepartmentRepositoryMockChildrenExpectation {
	if mmChildren.mock.funcChildren != nil {
		mmChildren.mock.t.Fatalf("DepartmentRepositoryMock.Children mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockChildrenExpectation{
		mock:   mmChildren.mock,
		params: &DepartmentRepositoryMockChildrenParams{ctx, id},
	}
	mmChildren.expectations = append(mmChildren.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Children return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockChildrenExpectation) Then(da1 []models.Department, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockChildrenResults{da1, err}
	return e.mock
}

// Children implements ports.DepartmentRepository
func (mmChildren *DepartmentRepositoryMock) Children(ctx context.Context, id uuid.UUID) (da1 []models.Department, err error) {
	mm_atomic.AddUint64(&mmChildren.beforeChildrenCounter, 1)
	defer mm_atomic.AddUint64(&mmChildren.afterChildrenCounter, 1)

	if mmChildren.inspectFuncChildren != nil {
		mmChildren.inspectFuncChildren(ctx, id)
	}

	mm_params := &DepartmentRepositoryMockChildrenParams{ctx, id}

	// Record call args
	mmChildren.ChildrenMock.mutex.Lock()
	mmChildren.ChildrenMock.callArgs = append(mmChildren.ChildrenMock.callArgs, mm_params)
	mmChildren.ChildrenMock.mutex.Unlock()

	for _, e := range mmChildren.ChildrenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmChildren.ChildrenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChildren.ChildrenMock.defaultExpectation.Counter, 1)
		mm_want := mmChildren.ChildrenMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockChildrenParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChildren.t.Errorf("DepartmentRepositoryMock.Children got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChildren.ChildrenMock.defaultExpectation.results
		if mm_results == nil {
			mmChildren.t.Fatal("No results are set for the DepartmentRepositoryMock.Children")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmChildren.funcChildren != nil {
		return mmChildren.funcChildren(ctx, id)
	}
	mmChildren.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Children. %v %v", ctx, id)
	return
}

// ChildrenAfterCounter returns a count of finished DepartmentRepositoryMock.Children invocations
func (mmChildren *DepartmentRepositoryMock) ChildrenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChildren.afterChildrenCounter)
}

// ChildrenBeforeCounter returns a count of DepartmentRepositoryMock.Children invocations
func (mmChildren *DepartmentRepositoryMock) ChildrenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChildren.beforeChildrenCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Children.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChildren *mDepartmentRepositoryMockChildren) Calls() []*DepartmentRepositoryMockChildrenParams {
	mmChildren.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockChildrenParams, len(mmChildren.callArgs))
	copy(argCopy, mmChildren.callArgs)

	mmChildren.mutex.RUnlock()

	return argCopy
}

// MinimockChildrenDone returns true if the count of the Children invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockChildrenDone() bool {
	for _, e := range m.ChildrenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChildrenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChildrenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChildren != nil && mm_atomic.LoadUint64(&m.afterChildrenCounter) < 1 {
		return false
	}
	return true
}

// MinimockChildrenInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockChildrenInspect() {
	for _, e := range m.ChildrenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Children with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChildrenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChildrenCounter) < 1 {
		if m.ChildrenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Children")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Children with params: %#v", *m.ChildrenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChildren != nil && mm_atomic.LoadUint64(&m.afterChildrenCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Children")
	}
}

type mDepartmentRepositoryMockCreate struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockCreateExpectation
	expectations       []*DepartmentRepositoryMockCreateExpectation

	callArgs []*DepartmentRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockCreateExpectation specifies expectation struct of the DepartmentRepository.Create
type DepartmentRepositoryMockCreateExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockCreateParams
	results *DepartmentRepositoryMockCreateResults
	Counter uint64
}

// DepartmentRepositoryMockCreateParams contains parameters of the DepartmentRepository.Create
type DepartmentRepositoryMockCreateParams struct {
	ctx context.Context
	dep models.Department
}

// DepartmentRepositoryMockCreateResults contains results of the DepartmentRepository.Create
type DepartmentRepositoryMockCreateResults struct {
	dp1 *models.Department
	err error
}

// Expect sets up expected params for DepartmentRepository.Create
func (mmCreate *mDepartmentRepositoryMockCreate) Expect(ctx context.Context, dep models.Department) *mDepartmentRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DepartmentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DepartmentRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &DepartmentRepositoryMockCreateParams{ctx, dep}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Create
func (mmCreate *mDepartmentRepositoryMockCreate) Inspect(f func(ctx context.Context, dep models.Department)) *mDepartmentRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by DepartmentRepository.Create
func (mmCreate *mDepartmentRepositoryMockCreate) Return(dp1 *models.Department, err error) *DepartmentRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DepartmentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DepartmentRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &DepartmentRepositoryMockCreateResults{dp1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the DepartmentRepository.Create method
func (mmCreate *mDepartmentRepositoryMockCreate) Set(f func(ctx context.Context, dep models.Department) (dp1 *models.Department, err error)) *DepartmentRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the DepartmentRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mDepartmentRepositoryMockCreate) When(ctx context.Context, dep models.Department) *DepartmentRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DepartmentRepositoryMock.Create mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &DepartmentRepositoryMockCreateParams{ctx, dep},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Create return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockCreateExpectation) Then(dp1 *models.Department, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockCreateResults{dp1, err}
	return e.mock
}

// Create implements ports.DepartmentRepository
func (mmCreate *DepartmentRepositoryMock) Create(ctx context.Context, dep models.Department) (dp1 *models.Department, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, dep)
	}

	mm_params := &DepartmentRepositoryMockCreateParams{ctx, dep}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockCreateParams{ctx, dep}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("DepartmentRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the DepartmentRepositoryMock.Create")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, dep)
	}
	mmCreate.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Create. %v %v", ctx, dep)
	return
}

// CreateAfterCounter returns a count of finished DepartmentRepositoryMock.Create invocations
func (mmCreate *DepartmentRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of DepartmentRepositoryMock.Create invocations
func (mmCreate *DepartmentRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mDepartmentRepositoryMockCreate) Calls() []*DepartmentRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Create")
	}
}

type mDepartmentRepositoryMockDelete struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockDeleteExpectation
	expectations       []*DepartmentRepositoryMockDeleteExpectation

	callArgs []*DepartmentRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockDeleteExpectation specifies expectation struct of the DepartmentRepository.Delete
type DepartmentRepositoryMockDeleteExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockDeleteParams
	results *DepartmentRepositoryMockDeleteResults
	Counter uint64
}

// DepartmentRepositoryMockDeleteParams contains parameters of the DepartmentRepository.Delete
type DepartmentRepositoryMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// DepartmentRepositoryMockDeleteResults contains results of the DepartmentRepository.Delete
type DepartmentRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for DepartmentRepository.Delete
func (mmDelete *mDepartmentRepositoryMockDelete) Expect(ctx context.Context, id uuid.UUID) *mDepartmentRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DepartmentRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DepartmentRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &DepartmentRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Delete
func (mmDelete *mDepartmentRepositoryMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mDepartmentRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by DepartmentRepository.Delete
func (mmDelete *mDepartmentRepositoryMockDelete) Return(err error) *DepartmentRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DepartmentRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DepartmentRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &DepartmentRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the DepartmentRepository.Delete method
func (mmDelete *mDepartmentRepositoryMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *DepartmentRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the DepartmentRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mDepartmentRepositoryMockDelete) When(ctx context.Context, id uuid.UUID) *DepartmentRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DepartmentRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &DepartmentRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Delete return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockDeleteExpectation) Then(err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements ports.DepartmentRepository
func (mmDelete *DepartmentRepositoryMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := &DepartmentRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("DepartmentRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the DepartmentRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished DepartmentRepositoryMock.Delete invocations
func (mmDelete *DepartmentRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of DepartmentRepositoryMock.Delete invocations
func (mmDelete *DepartmentRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mDepartmentRepositoryMockDelete) Calls() []*DepartmentRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Delete")
	}
}

type mDepartmentRepositoryMockGet struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockGetExpectation
	expectations       []*DepartmentRepositoryMockGetExpectation

	callArgs []*DepartmentRepositoryMockGetParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockGetExpectation specifies expectation struct of the DepartmentRepository.Get
type DepartmentRepositoryMockGetExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockGetParams
	results *DepartmentRepositoryMockGetResults
	Counter uint64
}

// DepartmentRepositoryMockGetParams contains parameters of the DepartmentRepository.Get
type DepartmentRepositoryMockGetParams struct {
	ctx context.Context
	id  uuid.UUID
}

// DepartmentRepositoryMockGetResults contains results of the DepartmentRepository.Get
type DepartmentRepositoryMockGetResults struct {
	dp1 *models.Department
	err error
}

// Expect sets up expected params for DepartmentRepository.Get
func (mmGet *mDepartmentRepositoryMockGet) Expect(ctx context.Context, id uuid.UUID) *mDepartmentRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DepartmentRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DepartmentRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &DepartmentRepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Get
func (mmGet *mDepartmentRepositoryMockGet) Inspect(f func(ctx context.Context, id uuid.UUID)) *mDepartmentRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by DepartmentRepository.Get
func (mmGet *mDepartmentRepositoryMockGet) Return(dp1 *models.Department, err error) *DepartmentRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DepartmentRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DepartmentRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &DepartmentRepositoryMockGetResults{dp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the DepartmentRepository.Get method
func (mmGet *mDepartmentRepositoryMockGet) Set(f func(ctx context.Context, id uuid.UUID) (dp1 *models.Department, err error)) *DepartmentRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the DepartmentRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mDepartmentRepositoryMockGet) When(ctx context.Context, id uuid.UUID) *DepartmentRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DepartmentRepositoryMock.Get mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &DepartmentRepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Get return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockGetExpectation) Then(dp1 *models.Department, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockGetResults{dp1, err}
	return e.mock
}

// Get implements ports.DepartmentRepository
func (mmGet *DepartmentRepositoryMock) Get(ctx context.Context, id uuid.UUID) (dp1 *models.Department, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := &DepartmentRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockGetParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("DepartmentRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the DepartmentRepositoryMock.Get")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished DepartmentRepositoryMock.Get invocations
func (mmGet *DepartmentRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of DepartmentRepositoryMock.Get invocations
func (mmGet *DepartmentRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mDepartmentRepositoryMockGet) Calls() []*DepartmentRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Get")
	}
}

type mDepartmentRepositoryMockGetAll struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockGetAllExpectation
	expectations       []*DepartmentRepositoryMockGetAllExpectation

	callArgs []*DepartmentRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockGetAllExpectation specifies expectation struct of the DepartmentRepository.GetAll
type DepartmentRepositoryMockGetAllExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockGetAllParams
	results *DepartmentRepositoryMockGetAllResults
	Counter uint64
}

// DepartmentRepositoryMockGetAllParams contains parameters of the DepartmentRepository.GetAll
type DepartmentRepositoryMockGetAllParams struct {
	ctx context.Context
}

// DepartmentRepositoryMockGetAllResults contains results of the DepartmentRepository.GetAll
type DepartmentRepositoryMockGetAllResults struct {
	da1 []models.Department
	err error
}

// Expect sets up expected params for DepartmentRepository.GetAll
func (mmGetAll *mDepartmentRepositoryMockGetAll) Expect(ctx context.Context) *mDepartmentRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("DepartmentRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &DepartmentRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &DepartmentRepositoryMockGetAllParams{ctx}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.GetAll
func (mmGetAll *mDepartmentRepositoryMockGetAll) Inspect(f func(ctx context.Context)) *mDepartmentRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by DepartmentRepository.GetAll
func (mmGetAll *mDepartmentRepositoryMockGetAll) Return(da1 []models.Department, err error) *DepartmentRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("DepartmentRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &DepartmentRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &DepartmentRepositoryMockGetAllResults{da1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the DepartmentRepository.GetAll method
func (mmGetAll *mDepartmentRepositoryMockGetAll) Set(f func(ctx context.Context) (da1 []models.Department, err error)) *DepartmentRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the DepartmentRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mDepartmentRepositoryMockGetAll) When(ctx context.Context) *DepartmentRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("DepartmentRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &DepartmentRepositoryMockGetAllParams{ctx},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockGetAllExpectation) Then(da1 []models.Department, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockGetAllResults{da1, err}
	return e.mock
}

// GetAll implements ports.DepartmentRepository
func (mmGetAll *DepartmentRepositoryMock) GetAll(ctx context.Context) (da1 []models.Department, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx)
	}

	mm_params := &DepartmentRepositoryMockGetAllParams{ctx}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockGetAllParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("DepartmentRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the DepartmentRepositoryMock.GetAll")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx)
	}
	mmGetAll.t.Fatalf("Unexpected call to DepartmentRepositoryMock.GetAll. %v", ctx)
	return
}

// GetAllAfterCounter returns a count of finished DepartmentRepositoryMock.GetAll invocations
func (mmGetAll *DepartmentRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of DepartmentRepositoryMock.GetAll invocations
func (mmGetAll *DepartmentRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mDepartmentRepositoryMockGetAll) Calls() []*DepartmentRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.GetAll")
	}
}

type mDepartmentRepositoryMockListSimilarByName struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockListSimilarByNameExpectation
	expectations       []*DepartmentRepositoryMockListSimilarByNameExpectation

	callArgs []*DepartmentRepositoryMockListSimilarByNameParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockListSimilarByNameExpectation specifies expectation struct of the DepartmentRepository.ListSimilarByName
type DepartmentRepositoryMockListSimilarByNameExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockListSimilarByNameParams
	results *DepartmentRepositoryMockListSimilarByNameResults
	Counter uint64
}

// DepartmentRepositoryMockListSimilarByNameParams contains parameters of the DepartmentRepository.ListSimilarByName
type DepartmentRepositoryMockListSimilarByNameParams struct {
	ctx    context.Context
	substr string
}

// DepartmentRepositoryMockListSimilarByNameResults contains results of the DepartmentRepository.ListSimilarByName
type DepartmentRepositoryMockListSimilarByNameResults struct {
	da1 []models.Department
	err error
}

// Expect sets up expected params for DepartmentRepository.ListSimilarByName
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) Expect(ctx context.Context, substr string) *mDepartmentRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("DepartmentRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &DepartmentRepositoryMockListSimilarByNameExpectation{}
	}

	mmListSimilarByName.defaultExpectation.params = &DepartmentRepositoryMockListSimilarByNameParams{ctx, substr}
	for _, e := range mmListSimilarByName.expectations {
		if minimock.Equal(e.params, mmListSimilarByName.defaultExpectation.params) {
			mmListSimilarByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSimilarByName.defaultExpectation.params)
		}
	}

	return mmListSimilarByName
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.ListSimilarByName
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) Inspect(f func(ctx context.Context, substr string)) *mDepartmentRepositoryMockListSimilarByName {
	if mmListSimilarByName.mock.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.ListSimilarByName")
	}

	mmListSimilarByName.mock.inspectFuncListSimilarByName = f

	return mmListSimilarByName
}

// Return sets up results that will be returned by DepartmentRepository.ListSimilarByName
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) Return(da1 []models.Department, err error) *DepartmentRepositoryMock {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("DepartmentRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	if mmListSimilarByName.defaultExpectation == nil {
		mmListSimilarByName.defaultExpectation = &DepartmentRepositoryMockListSimilarByNameExpectation{mock: mmListSimilarByName.mock}
	}
	mmListSimilarByName.defaultExpectation.results = &DepartmentRepositoryMockListSimilarByNameResults{da1, err}
	return mmListSimilarByName.mock
}

// Set uses given function f to mock the DepartmentRepository.ListSimilarByName method
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) Set(f func(ctx context.Context, substr string) (da1 []models.Department, err error)) *DepartmentRepositoryMock {
	if mmListSimilarByName.defaultExpectation != nil {
		mmListSimilarByName.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.ListSimilarByName method")
	}

	if len(mmListSimilarByName.expectations) > 0 {
		mmListSimilarByName.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.ListSimilarByName method")
	}

	mmListSimilarByName.mock.funcListSimilarByName = f
	return mmListSimilarByName.mock
}

// When sets expectation for the DepartmentRepository.ListSimilarByName which will trigger the result defined by the following
// Then helper
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) When(ctx context.Context, substr string) *DepartmentRepositoryMockListSimilarByNameExpectation {
	if mmListSimilarByName.mock.funcListSimilarByName != nil {
		mmListSimilarByName.mock.t.Fatalf("DepartmentRepositoryMock.ListSimilarByName mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockListSimilarByNameExpectation{
		mock:   mmListSimilarByName.mock,
		params: &DepartmentRepositoryMockListSimilarByNameParams{ctx, substr},
	}
	mmListSimilarByName.expectations = append(mmListSimilarByName.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.ListSimilarByName return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockListSimilarByNameExpectation) Then(da1 []models.Department, err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockListSimilarByNameResults{da1, err}
	return e.mock
}

// ListSimilarByName implements ports.DepartmentRepository
func (mmListSimilarByName *DepartmentRepositoryMock) ListSimilarByName(ctx context.Context, substr string) (da1 []models.Department, err error) {
	mm_atomic.AddUint64(&mmListSimilarByName.beforeListSimilarByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmListSimilarByName.afterListSimilarByNameCounter, 1)

	if mmListSimilarByName.inspectFuncListSimilarByName != nil {
		mmListSimilarByName.inspectFuncListSimilarByName(ctx, substr)
	}

	mm_params := &DepartmentRepositoryMockListSimilarByNameParams{ctx, substr}

	// Record call args
	mmListSimilarByName.ListSimilarByNameMock.mutex.Lock()
	mmListSimilarByName.ListSimilarByNameMock.callArgs = append(mmListSimilarByName.ListSimilarByNameMock.callArgs, mm_params)
	mmListSimilarByName.ListSimilarByNameMock.mutex.Unlock()

	for _, e := range mmListSimilarByName.ListSimilarByNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmListSimilarByName.ListSimilarByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockListSimilarByNameParams{ctx, substr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSimilarByName.t.Errorf("DepartmentRepositoryMock.ListSimilarByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSimilarByName.ListSimilarByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmListSimilarByName.t.Fatal("No results are set for the DepartmentRepositoryMock.ListSimilarByName")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmListSimilarByName.funcListSimilarByName != nil {
		return mmListSimilarByName.funcListSimilarByName(ctx, substr)
	}
	mmListSimilarByName.t.Fatalf("Unexpected call to DepartmentRepositoryMock.ListSimilarByName. %v %v", ctx, substr)
	return
}

// ListSimilarByNameAfterCounter returns a count of finished DepartmentRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *DepartmentRepositoryMock) ListSimilarByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.afterListSimilarByNameCounter)
}

// ListSimilarByNameBeforeCounter returns a count of DepartmentRepositoryMock.ListSimilarByName invocations
func (mmListSimilarByName *DepartmentRepositoryMock) ListSimilarByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSimilarByName.beforeListSimilarByNameCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.ListSimilarByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSimilarByName *mDepartmentRepositoryMockListSimilarByName) Calls() []*DepartmentRepositoryMockListSimilarByNameParams {
	mmListSimilarByName.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockListSimilarByNameParams, len(mmListSimilarByName.callArgs))
	copy(argCopy, mmListSimilarByName.callArgs)

	mmListSimilarByName.mutex.RUnlock()

	return argCopy
}

// MinimockListSimilarByNameDone returns true if the count of the ListSimilarByName invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockListSimilarByNameDone() bool {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSimilarByNameInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockListSimilarByNameInspect() {
	for _, e := range m.ListSimilarByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.ListSimilarByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSimilarByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		if m.ListSimilarByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.ListSimilarByName")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.ListSimilarByName with params: %#v", *m.ListSimilarByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSimilarByName != nil && mm_atomic.LoadUint64(&m.afterListSimilarByNameCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.ListSimilarByName")
	}
}

type mDepartmentRepositoryMockUpdate struct {
	mock               *DepartmentRepositoryMock
	defaultExpectation *DepartmentRepositoryMockUpdateExpectation
	expectations       []*DepartmentRepositoryMockUpdateExpectation

	callArgs []*DepartmentRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// DepartmentRepositoryMockUpdateExpectation specifies expectation struct of the DepartmentRepository.Update
type DepartmentRepositoryMockUpdateExpectation struct {
	mock    *DepartmentRepositoryMock
	params  *DepartmentRepositoryMockUpdateParams
	results *DepartmentRepositoryMockUpdateResults
	Counter uint64
}

// DepartmentRepositoryMockUpdateParams contains parameters of the DepartmentRepository.Update
type DepartmentRepositoryMockUpdateParams struct {
	ctx context.Context
	dep models.Department
}

// DepartmentRepositoryMockUpdateResults contains results of the DepartmentRepository.Update
type DepartmentRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for DepartmentRepository.Update
func (mmUpdate *mDepartmentRepositoryMockUpdate) Expect(ctx context.Context, dep models.Department) *mDepartmentRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DepartmentRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DepartmentRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &DepartmentRepositoryMockUpdateParams{ctx, dep}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the DepartmentRepository.Update
func (mmUpdate *mDepartmentRepositoryMockUpdate) Inspect(f func(ctx context.Context, dep models.Department)) *mDepartmentRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for DepartmentRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by DepartmentRepository.Update
func (mmUpdate *mDepartmentRepositoryMockUpdate) Return(err error) *DepartmentRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DepartmentRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DepartmentRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &DepartmentRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the DepartmentRepository.Update method
func (mmUpdate *mDepartmentRepositoryMockUpdate) Set(f func(ctx context.Context, dep models.Department) (err error)) *DepartmentRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the DepartmentRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the DepartmentRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the DepartmentRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mDepartmentRepositoryMockUpdate) When(ctx context.Context, dep models.Department) *DepartmentRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DepartmentRepositoryMock.Update mock is already set by Set")
	}

	expectation := &DepartmentRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &DepartmentRepositoryMockUpdateParams{ctx, dep},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up DepartmentRepository.Update return parameters for the expectation previously defined by the When method
func (e *DepartmentRepositoryMockUpdateExpectation) Then(err error) *DepartmentRepositoryMock {
	e.results = &DepartmentRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements ports.DepartmentRepository
func (mmUpdate *DepartmentRepositoryMock) Update(ctx context.Context, dep models.Department) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, dep)
	}

	mm_params := &DepartmentRepositoryMockUpdateParams{ctx, dep}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := DepartmentRepositoryMockUpdateParams{ctx, dep}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("DepartmentRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the DepartmentRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, dep)
	}
	mmUpdate.t.Fatalf("Unexpected call to DepartmentRepositoryMock.Update. %v %v", ctx, dep)
	return
}

// UpdateAfterCounter returns a count of finished DepartmentRepositoryMock.Update invocations
func (mmUpdate *DepartmentRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of DepartmentRepositoryMock.Update invocations
func (mmUpdate *DepartmentRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to DepartmentRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mDepartmentRepositoryMockUpdate) Calls() []*DepartmentRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*DepartmentRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *DepartmentRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *DepartmentRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DepartmentRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to DepartmentRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to DepartmentRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DepartmentRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBreadcrumbsInspect()

		m.MinimockChildrenInspect()

		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()

		m.MinimockListSimilarByNameInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DepartmentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DepartmentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBreadcrumbsDone() &&
		m.MinimockChildrenDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockListSimilarByNameDone() &&
		m.MinimockUpdateDone()
}
