\documentclass[a4paper,12pt]{extarticle}
%Gummi|065|=)
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[left=3cm,right=1.5cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{amsmath}
\usepackage{caption}
% \usepackage{color}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{verbatimbox}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{indentfirst}
\usepackage{alltt}

\usepackage[cache=false]{minted}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%

\linespread{1.3}
\begin{document}

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА

    \begin{table}[h!]
     \begin{center}
     \begin{tabular}{  c  p{0.8\textwidth}  }
     \raisebox{-\totalheight}{\includegraphics[width=0.15\textwidth, height=30mm]{bmstu.png}}
      & 
      \begin{center}
          Министерство образования и науки Российской Федерации \\
      Федеральное государственное бюджетное образовательное учреждение высшего образования  \\
    
      «Московский государственный технический университет \\
      имени Н.Э. Баумана» \\
    
      (МГТУ им. Н.Э. Баумана)
      \end{center}
      \\
      \hline
      \end{tabular}
      \end{center}
\end{table}

\textbf{ }
\\
\textbf{ФАКУЛЬТЕТ: } \underline{Информатика и системы управления}
\\
\textbf{КАФЕДРА: } \underline{Программное обеспечение ЭВМ и информационные технологии}
\\
\textbf{ДИСЦИПЛИНА: } \underline{Типы и структуры данных}
\\
\textbf{ТЕМА: } \underline{Обработка очередей}
\\
\textbf{ВАРИАНТ: } \underline{6}

\vspace{1cm}

\begin{center}
    \large{\textbf{\underline{ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ №5}}}
\end{center}

\textbf{ }
\vspace{1cm}
\\
\textbf{Студент: } \hspace{5.2cm} \underset{\text{(подпись, дата)}}{\underline{\hspace{0.3\textwidth}}} \textit{ Княжев А. В. }
\vspace{0.2cm}
\\
\textbf{Преподаватель: } \hspace{4cm} \underset{\text{(подпись, дата)}}{\underline{\hspace{0.3\textwidth}}} \textit{ Силантьева А. В. }

\vspace{7cm}
\begin{center} \textit{2021 г.} \end{center}
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Условие задачи}
Система массового обслуживания состоит из обслуживающего аппарата (ОА) и двух очередей заявок двух типов.

\includegraphics[width=\textwidth]{schema.png}

Заявки 1-го и 2-го типов поступают в <<хвосты>> своих очередей по случайному закону с интервалами времени Т1 и Т2, равномерно распределенными от $1$ до $5$ и от $0$ до $3$ единиц времени (е.в.) соответственно. В ОА они поступают из <<головы>> очереди по одной и обслуживаются также равновероятно за времена Т3 и Т4, распределенные от $0$ до $4$ е.в. и от $0$ до $1$ е.в. соответственно, после чего покидают систему (все времена --- вещественного типа). В начале процесса в системе заявок нет.

Заявка 2-го типа может войти в ОА, если в системе нет заявок 1-го типа. Если в момент обслуживания заявки 2-го типа в пустую очередь входит заявка 1-го типа, то она немедленно поступает на обслуживание; обработка заявки 2-го типа прерывается, и она возвращается в <<хвост>> своей очереди (система с абсолютным приоритетом и повторным обслуживанием).

Смоделировать процесс обслуживания первых $1000$ заявок 1-го типа, выдавая после обслуживания каждых $100$ заявок 1-го типа информацию о текущей и средней длине каждой очереди. В конце процесса выдать общее время моделирования и количестве вошедших в систему и вышедших из нее заявок обоих типов, среднем времени пребывания заявок в очереди, количестве «выброшенных» заявок второго типа. Обеспечить по требованию пользователя выдачу на экран адресов элементов очереди при удалении и добавлении элементов. Проследить, возникает ли при этом фрагментация памяти.

\newpage

\section{Техническое задание}
Система массового обслуживания состоит из обслуживающих аппаратов (ОА) и очередей заявок двух типов, различающихся временем прихода и обработки. Заявки поступают в очереди по случайному закону с различными интервалами времени (в зависимости от варианта задания), равномерно распределенными от начального значения (иногда от нуля) до максимального количества единиц времени. В ОА заявки поступают из <<головы>> очереди по одной и обслуживаются за указанные в задании времена, распределенные равновероятно от минимального до максимального значений (все времена --- вещественного типа).

Требуется смоделировать процесс обслуживания первых $1000$ заявок первого типа, выдавая после обслуживания каждых $100$ заявок первого типа информацию о текущей и средней длине каждой очереди и о среднем времени пребывания заявок каждого типа в очереди. В конце процесса необходимо выдать на экран общее время моделирования, время простоя ОА, количество вошедших в систему и вышедших из нее заявок первого и второго типов.

Очередь необходимо представить в виде вектора и списка. Все операции должны быть оформлены подпрограммами. Алгоритм для реализации задачи один, независимо от формы представления очереди. Необходимо сравнить эффективность различного представления очереди по времени выполнения программы и по требуемой памяти. При реализации очереди списком нужно проследить, каким образом происходит выделение и освобождение участков памяти, для чего по запросу пользователя необходимо выдать на экран адреса памяти, содержащие элементы очереди при добавлении или удалении очередного элемента.

Длительности обработки заявок и интервалы между их приходом (единицы времени --- е.в.) --- случайные равномерно распределенные числа вещественного типа в указанном диапазоне (например, от $t1$ до $t2$).

Рассогласование между средними ожидаемыми временами и временами, полученными в моделирующей программе должно быть \textit{\textbf{не больше $2$–$3$\%}}.

Сравнить эффективность (по памяти и по времени выполнения) обработки очереди списком и массивом.

Программа должна выводить меню с возможностью выбирать варианты. При вводе нуля на запрос варианта меню, происходит выход из программы.

\subsection{Общие входные данные}
\begin{itemize}
    \item[$*$] номер выбранного пункта меню.
\end{itemize}

\subsection{Входные и выходные данные пунктов меню}
\subsubsection{Моделирование процесса с использованием очереди-массива}

\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T1$, с которым заявки приходят в первую очередь;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T2$, с которым заявки приходят во вторую очередь;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T3$, в течение которого заявки из первой очереди обрабатываются обслуживающим аппаратом;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T4$, в течение которого заявки из второй очереди обрабатываются обслуживающим аппаратом.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] для каждой 100-ой вышедшей заявки первого типа информация о текущей и средней длине каждой очереди;
    \item[$*$] результат моделирования:
    \begin{itemize}
    	\item[---] общее время моделирования;
    	\item[---] теоретическое время моделирования;
    	\item[---] сравнения этих времен, погрешность моделирования;
    	\item[---] количество вошедших в систему и вышедших из нее заявок каждого типа;
    	\item[---] среднее время пребывания заявок в очереди для каждого типа;
    	\item[---] количество <<выброшенных>> заявок второго типа.
    \end{itemize}
\end{itemize}

\subsubsection{Моделирование процесса с использованием очереди-списка}

\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] ответ на вопрос, нужно ли выводить адреса добавляемых и удаляемых элементов;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T1$, с которым заявки приходят в первую очередь;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T2$, с которым заявки приходят во вторую очередь;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T3$, в течение которого заявки из первой очереди обрабатываются обслуживающим аппаратом;
    \item[$*$] два вещественных числа --- максимальное и минимальное время $T4$, в течение которого заявки из второй очереди обрабатываются обслуживающим аппаратом.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] для каждой 100-ой вышедшей заявки первого типа информация о текущей и средней длине каждой очереди;
    \item[$*$] результат моделирования:
    \begin{itemize}
    	\item[---] общее время моделирования;
    	\item[---] теоретическое время моделирования;
    	\item[---] сравнения этих времен, погрешность моделирования;
    	\item[---] количество вошедших в систему и вышедших из нее заявок каждого типа;
    	\item[---] среднее время пребывания заявок в очереди для каждого типа;
    	\item[---] количество <<выброшенных>> заявок второго типа.
    \end{itemize}
    \item[$*$] опционально адреса добавляемых и удаляемых элементов.
\end{itemize}

\subsubsection{Сравнение скорости работы различных реализаций очереди}

\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] количество элементов, добавляемых/удаляемых в очереди;
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] время выполнения операций push и pop для очереди-списка и очереди-массива;
    \item[$*$] сравнение этих времен.
\end{itemize}

\subsubsection{Сравнение потребления памяти различных реализаций очереди}

\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] количество элементов очереди;
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] объемы памяти, занимаемые очередью-списком и очередью-массивом;
    \item[$*$] сравнение этих объемов.
\end{itemize}


\subsection{Действие программы}
Программа осуществляет работу со очередями в формате массива и списка.

\subsection{Обращение к программе}
Программа может быть запущена из командных оболочек \texttt{sh/bash/zsh/fish}, а также от IDE, способных работать с языком Си. Программа не принимает никаких аргументов. Название исполняемого файла --- app.exe, так что команда может быть вызвана из командной оболочки в корневой папке проекта как:

\begin{minted}{bash}
$ ./app.exe
\end{minted}

\subsection{Аварийные ситуации}
\subsubsection{Общие аварийные ситуации}
\begin{enumerate}
    \item невалидный номер пункта меню (строка или пустая строка);
    \item неверный номер пункта меню (такого пунта меню не существует).
\end{enumerate}

\subsubsection{Пункт меню №1}
\begin{enumerate}
    \item невалидные времена;
    \item времена с нарушениями логики, когда минимальный промежуток больше максимального.
\end{enumerate}

\subsubsection{Пункт меню №2}
\begin{enumerate}
    \item невалидный ответ на вопрос о том, нужно ли выводить адреса;
    \item некорретный ответ на вопрос о том, нужно ли выводить адреса;
    \item невалидные времена;
    \item времена с нарушениями логики, когда минимальный промежуток больше максимального.
\end{enumerate}

\subsubsection{Пункт меню №3}
\begin{enumerate}
    \item слишком большое количество элементов;
    \item слишком маленькое количество элементов;
    \item невалидное количество элементов.
\end{enumerate}

\subsubsection{Пункт меню №4}
\begin{enumerate}
    \item слишком большое количество элементов;
    \item слишком маленькое количество элементов;
    \item невалидное количество элементов.
\end{enumerate}

\newpage

\section{Структуры данных}
В данной работе используется статичесике массивы, записи и односвязные списки.

\subsection{Модуль для работы с ошибками}
\subsubsection{Типы данных}
\begin{minted}{C}
/**
 * text - текст ошибки;
 * code - код ошибки;
 * func - функция, в которой случилась ошибка.
 */
typedef struct 
{
    const char *text;
    int code;
    const char *func;
} error_t;
\end{minted}


\subsubsection{Функции}
\begin{minted}{C}
/**
 * Создание новой ошибки.
 * text - текст ошибки;
 * code - код ошибки;
 * func - функция, в которой случилась ошибка.
 */
error_t new_error(const char *text, int code, const char *func);
\end{minted}


\begin{minted}{C}
/**
 * Создание ошибки-маркера успеха.
 * func - функция, в которой был создан "успех".
 */
error_t new_success(const char *func);
\end{minted}



\begin{minted}{C}
/**
 * Проверка, отображает ли ошибка ошибочную ситуацию.
 * err - исходная ошибка.
 */
bool is_failure(error_t err);
\end{minted}


\subsection{Модуль для работы со строками}
\subsubsection{Основные константы}
\begin{minted}{C}
#define MYSTRING_SIZE 257
\end{minted}


\subsubsection{Типы данных}
\begin{minted}{C}
/**
 * Тип строки длиной 256 символов + терминальный нуль.
 */
typedef char mystring_t[MYSTRING_SIZE];
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/**
 * Чтение строки из файла.
 * f - файл;
 * str - строка, в которую считываем.
 */
error_t f_read_line(FILE *f, mystring_t str);
\end{minted}

\begin{minted}{C}
/**
 * Чтение целого числа из стандартного потока ввода.
 * n - считываемое число.
 */
error_t read_int(int *n);
\end{minted}

\subsection{Модуль <<ядра>> программы}
\subsubsection{Функции}
\begin{minted}{C}
/**
 * Запуск основного диалога программы.
 */
error_t eng_work();
\end{minted}

\subsection{Модуль для тестирования скорости работы}
\subsubsection{Основные константы}
\begin{minted}{C}
/**
 * Количество запусков тестов производительности.
 */
#define BENCH_NUM_OF_RUNS 1000
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/**
 * Замер времени операции "push" для очереди-массива.
 * n - количество элементов очереди;
 * timer - среднее время выполнения операции.
 */
error_t bench_queue_arr_push(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/**
 * Замер времени операции "pop" для очереди-массива.
 * n - количество элементов очереди;
 * timer - среднее время выполнения операции.
 */
error_t bench_queue_arr_pop(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/**
 * Замер времени операции "push" для очереди-списка.
 * n - количество элементов очереди;
 * timer - среднее время выполнения операции.
 */
error_t bench_queue_list_push(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/**
 * Замер времени операции "pop" для очереди-списка.
 * n - количество элементов очереди;
 * timer - среднее время выполнения операции.
 */
error_t bench_queue_list_pop(size_t n, long long *timer);
\end{minted}

\subsection{Модуль для работы с очередью-массивом}
\subsubsection{Основные константы}
\begin{minted}{C}
/**
 * Максимальное количество элементов очереди-массива.
 */
#define QA_QUEUE_SIZE 20000
\end{minted}

\subsubsection{Типы данных}

\begin{minted}{C}
/**
 * Очередь-массив.
 * content - содержимое очереди;
 * head - указатель на голову очереди, то есть на адрес
 *        удаляемого элемента;
 * tail - указатель на хвост очереди, то есть на адрес
 *        куда будет вставляться очередной элемент;
 * len - длина очереди.
 */
typedef struct queue_array_t
{
    task_t content[QA_QUEUE_SIZE];
    task_t *head;
    task_t *tail;
    size_t len;
} queue_array_t;
\end{minted}

\subsubsection{Функции}

\begin{minted}{C}
/**
 * Создание пустой очереди.
 */
queue_array_t qa_create();
\end{minted}

\begin{minted}{C}
/**
 * Добавление элемента в очередь.
 * q - очередь;
 * el - добавляемый элемент.
 */
error_t qa_push(void *q, task_t el);
\end{minted}

\begin{minted}{C}
/**
 * Удаление элемента из очереди.
 * q - очередь;
 * el - удаленный элемент.
 */
error_t qa_pop(void *q, task_t *el);
\end{minted}

\begin{minted}{C}
/**
 * Проверка очереди на пустоту.
 * q - очередь.
 */
bool qa_empty(void *q);
\end{minted}

\begin{minted}{C}
/**
 * Получение длины очереди.
 * q - очередь;
 * len - длина очереи.
 */
error_t qa_len(void *q, size_t *len);	
\end{minted}


\subsection{Модуль для работы с очередью-списком}
\subsubsection{Типы данных}

\begin{minted}{C}
/**
 * Элемент очереди-списка.
 * content - содержимое элемента очереди;
 * next - указатель на следующий элемент очереди.
 */
typedef struct queue_node_t queue_node_t;
struct queue_node_t
{
    task_t content;
    queue_node_t *next;
};
\end{minted}

\begin{minted}{C}
/**
 * Очередь-список.
 * head - указатель на голову очереди (откуда удаляем);
 * tail - указатель на хвост очереди (после которого добавляем);
 * len - длина очереди.
 */
typedef struct queue_list_t
{
    queue_node_t *head;
    queue_node_t *tail;
    size_t len;
} queue_list_t;
\end{minted}

\subsubsection{Функции}

\begin{minted}{C}
/**
 * Создание пустой очереди.
 */
queue_list_t ql_create();
\end{minted}

\begin{minted}{C}
/**
 * Добавление элемента в очередь.
 * q - очередь;
 * el - добавляемый элемент.
 */
error_t ql_push(void *q, task_t el);
\end{minted}

\begin{minted}{C}
/**
 * Удаление элемента из очереди.
 * q - очередь;
 * el - удаленный элемент.
 */
error_t ql_pop(void *q, task_t *el);
\end{minted}

\begin{minted}{C}
/**
 * Проверка очереди на пустоту.
 * q - очередь.
 */
bool ql_empty(void *q);
\end{minted}

\begin{minted}{C}
/**
 * Освобождение очереди-списка.
 * q - очередь.
 */
void ql_free(void *q);
\end{minted}

\subsection{Модуль для работы с обрабатывающий автоматом}
\subsubsection{Основные константы}
\begin{minted}{C}
	
\end{minted}


\subsubsection{Типы данных}

\begin{minted}{C}
/**
 * Тип заявки.
 * primary - первичная, из первой очереди;
 * secondary - вторичная, из второй очереди.
 */
typedef enum task_type_t
{
    primary,
    secondary,
} task_type_t;
\end{minted}

\begin{minted}{C}
/**
 * Заявка.
 * content - содержимое заявки;
 * type - типа заявки;
 * enter_time - время приходя заявки в очередь.
 */
typedef struct task_t
{
    int content;
    task_type_t type;
    double enter_time;
} task_t;
\end{minted}

\begin{minted}{C}
/**
 * Обрабатывающий автомат.
 * current_task - текущая заявка;
 * is_working - работает ли автомат?
 * start_time - время начала обработки текущей заявки;
 * process_min_time - минимальное время обработки заявок каждого типа;
 * process_min_time - максимальное время обработки заявок каждого типа.
 */
typedef struct oa_t
{
    task_t current_task;
    bool is_working;
    double start_time;
    double process_time;
    double process_min_time[2], process_max_time[2];
} oa_t;
\end{minted}

\subsubsection{Функции}

\begin{minted}{C}
/**
 * Добавление заявки в автомат.
 * oa - обрабатывающий автомат;
 * task - заявка;
 * timer - текущее время.
 */
error_t oa_start(oa_t *oa, task_t task, double timer);
\end{minted}

\begin{minted}{C}
/**
 * Окончание работы автомата над текущей заявкой.
 * oa - обрабатывающий автомат;
 * exited - вышедшая заявка.
 */
error_t oa_finish(oa_t *oa, task_t *exited);
\end{minted}

\begin{minted}{C}
/**
 * Пришло ли время аппарату оканчивать работу над заявкой?
 * oa - обрабатывающий автомат;
 * timer - текущее время.
 */
bool oa_done(oa_t *oa, double timer);
\end{minted}

\begin{minted}{C}
/**
 * Время, когда автомат закончит работать над текущей заявкой.
 * oa - обрабатывающий автомат.
 */
double oa_end_time(oa_t *oa);
\end{minted}

\begin{minted}{C}
/**
 * Новая заявка.
 * type - тип заявки;
 * timer - текущее время.
 */
task_t task_new(task_type_t type, double timer);
\end{minted}

\subsection{Модуль для моделирования процесса}

\subsubsection{Основные константы}
\begin{minted}{C}
/**
 * Количество обработанных заявок первого типа для выхода.
 */
#define PROCESSED_STOP 1000
\end{minted}

\begin{minted}{C}
/**
 * Количество обработанных заявок первого типа для вывода статистики.
 */
#define PROCESSED_STATS 100
\end{minted}


\subsubsection{Типы данных}
\begin{minted}{C}
/**
 * Параметр моделирования.
 * push - функция "push" для очереди;
 * pop - функция "pop" для очереди;
 * len - функция "len" для очереди;
 * empty - проверка очереди на пустоту;
 * q1 - первая очередь;
 * q2 - вторая очередь;
 * t1_min, t1_max - диапазон времени на T1;
 * t2_min, t2_max - диапазон времени на T2;
 * t3_min, t3_max - диапазон времени на T3;
 * t4_min, t4_max - диапазон времени на T4.
 */
typedef struct process_config_t
{
    error_t (*push) (void *, task_t);
    error_t (*pop) (void *, task_t *);
    error_t (*len) (void *, size_t *);
    bool (*empty) (void *);

    void *q1;
    void *q2;

    double t1_min, t1_max;
    double t2_min, t2_max;
    double t3_min, t3_max;
    double t4_min, t4_max;
} process_config_t;
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/**
 * Основной цикл моделирования процесса.
 * config - настройки моделирования.
 */
error_t process(process_config_t config);
\end{minted}
\begin{minted}{C}
	
\end{minted}




\newpage
\section{Описания алгоритмов}


\begin{enumerate}
    \item вывод главного меню;
    \item получение у пользователя номера пункта меню:
\end{enumerate}

\subsection{Пункт меню №1}
\begin{enumerate}
    \item получить у пользователя времена;
    \item добавить их в параметры запуска моделирования;
    \item для текущего времени проверяется, какое событие может сейчас произойти: добавление в одну из очередей или окончание работы автомата;
    \item в зависимости от загруженности автомата после обработки добавлений происходит проверка занятости автомата;
    \item если он пуст, в него кладутся заявки по приоритетности;
    \item если не пуст, но там есть заявка второго типа, а в очереди есть заявки первого типа, то заявка первого типа вымещает ту, что в автомате, которая возвращается во вторую очередь;
    \item вывод подробной статистики моделирования.
\end{enumerate}

\subsection{Пункт меню №2}
\begin{enumerate}
    \item см. предыдущий пункт.
\end{enumerate}

\subsection{Пункт меню №3}
\begin{enumerate}
    \item получить у пользователя количество элементов;
    \item для каждого вида очереди посчитать среднюю скорость добавления и удаления введенного количества элементов и вывести на экран;
    \item вывести процентное превосходство скорости работы очереди-массива над очередью-списоком.
\end{enumerate}

\subsection{Пункт меню №4}
\begin{enumerate}
    \item получить у пользователя количество элементов;
    \item для каждого вида очереди посчитать количество памяти, затрачиваемое для хранения введенного количества элементов;
    \item вывести процентное превосходство объема занимаемой памяти очереди-списка над очередью-массивом.
\end{enumerate}

\newpage

\section{Тестирование}
Для проверок корректности работы программы было проведено функциональное тестирование. Таблица с тестовыми данными для <<позитивных>> и <<негативных>> случаев приведена ниже.

Так как входных/выходных данных может быть очень много, то в соответствующих полях могут быть указаны наиболее значимые части.

\subsection{<<Негативные>> тесты}
\subsubsection{Ввод невалидного пункта меню}

\textbf{Входные данные: }
abc

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---

\textbf{Результат: }
104: Строка не является корректным числом (to\_integer)

% ---

\subsubsection{Ввод некорректного пункта меню}

\textbf{Входные данные: }
12

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---

\textbf{Результат: }
161: введен неверный пункт меню (main\_menu\_dialog)

% ---

\subsubsection{Невалидное время}

\textbf{Входные данные: }
1 или 2

\textbf{T1: }
abc 3

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
161: неверный диапазон T1 (read\_config\_times\_dialog)

% ---

\subsubsection{Меньшая граница времени больше большей}

\textbf{Входные данные: }
1 или 2

\textbf{T1: }
1 3

\textbf{T2: }
3 1

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
161: неверный диапазон T2 (read\_config\_times\_dialog)

% ---

\subsubsection{Ввод невалидного количества элементов}

\textbf{Входные данные: }
3 $\rightarrow$ abc или 4 $\rightarrow$ a

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
104: строка не является корректным числом (to_integer)

% ---

\subsubsection{Ввод неверного количества элементов}

\textbf{Входные данные: }
3 $\rightarrow$ 1000000 или 4 $\rightarrow$ 1000000

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
100: слишком большой размер (eng\_work)

% ---



\subsection{<<Позитивные>> тесты}

\subsubsection{Моделирование с параметрами из задания для массива}

\textbf{Входные данные: }
1

\textbf{T1: }
1 5

\textbf{T2: }
0 3

\textbf{T3: }
0 4

\textbf{T4: }
0 1


\textbf{Результат: }

\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 3064.6
Расчетное время моделирования = 3000.0
Расхождение = 2.1 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1000
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 2006
  Количество вышедших заявок = 1958
  Среднее время пребывания заявки в очереди = 0.0
  Количество "выброшенных" заявок = 635
\end{minted}

\newpage

\subsubsection{Моделирование с параметрами из задания для списка}

\textbf{Входные данные: }
2 $\rightarrow$ 2

\textbf{T1: }
1 5

\textbf{T2: }
0 3

\textbf{T3: }
0 4

\textbf{T4: }
0 1


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 2959.8
Расчетное время моделирования = 3000.0
Расхождение = 1.3 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1000
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 1976
  Количество вышедших заявок = 1756
  Среднее время пребывания заявки в очереди = 0.1
  Количество "выброшенных" заявок = 590
\end{minted}

\subsubsection{Заявки в первую очередь поступают очень часто}

\textbf{Входные данные: }
1

\textbf{T1: }
0 1

\textbf{T2: }
1 6

\textbf{T3: }
0 3

\textbf{T4: }
0 3


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 1513.6
Расчетное время моделирования = 1500.0
Расхождение = 0.9 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 3016
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 1.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 427
  Количество вышедших заявок = 0
  Среднее время пребывания заявки в очереди = 0.0
  Количество "выброшенных" заявок = 0
\end{minted}

\subsubsection{Автомат очень быстро обрабатывает заявки}

\textbf{Входные данные: }
1

\textbf{T1: }
0 10

\textbf{T2: }
0 10

\textbf{T3: }
0 1

\textbf{T4: }
0 1


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 5015.7
Расчетное время моделирования = 5000.0
Расхождение = 0.3 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1000
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 992
  Количество вышедших заявок = 992
  Среднее время пребывания заявки в очереди = 0.0
  Количество "выброшенных" заявок = 101
\end{minted}


\subsubsection{Все времена одинаковы}

\textbf{Входные данные: }
1

\textbf{T1: }
0 4

\textbf{T2: }
0 4

\textbf{T3: }
0 4

\textbf{T4: }
0 4


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 2049.1
Расчетное время моделирования = 2000.0
Расхождение = 2.4 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1019
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 1049
  Количество вышедших заявок = 5
  Среднее время пребывания заявки в очереди = 20.1
  Количество "выброшенных" заявок = 23
\end{minted}

\subsubsection{Заявки в первой очереди приходят и обрабатываются очень быстро}

\textbf{Входные данные: }
1

\textbf{T1: }
0 1

\textbf{T2: }
0 10

\textbf{T3: }
0 1

\textbf{T4: }
0 10


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 511.6
Расчетное время моделирования = 500.0
Расхождение = 2.3 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1023
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 103
  Количество вышедших заявок = 0
  Среднее время пребывания заявки в очереди = 0.2
  Количество "выброшенных" заявок = 1
\end{minted}

\subsubsection{Заявки в первой очереди приходят и обрабатываются очень медленно}

\textbf{Входные данные: }
1

\textbf{T1: }
0 10

\textbf{T2: }
0 1

\textbf{T3: }
0 10

\textbf{T4: }
0 1


\textbf{Результат: }
\begin{minted}{text}
Работа системы завершена.
Общее время моделирования = 5010.5
Расчетное время моделирования = 5000.0
Расхождение = 0.2 %

Информация об очередях
ОЧЕРЕДЬ 1:
  Количество вошедших заявок = 1006
  Количество вышедших заявок = 1000
  Среднее время пребывания заявки в очереди = 0.0
ОЧЕРЕДЬ 2:
  Количество вошедших заявок = 9990
  Количество вышедших заявок = 25
  Среднее время пребывания заявки в очереди = 58.7
  Количество "выброшенных" заявок = 8
\end{minted}


\subsubsection{Сравнение скорости работы очереди-массива и очереди-списка}

\textbf{Входные данные: }
3 $\rightarrow$ 6000

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
\begin{minted}{text}
Для 1000 запусков и 6000 элементов.
Очередь-массив
  PUSH: 97 us
  POP: 79 us
Очередь-список
  PUSH: 145 us
  POP: 146 us

Преимущество очереди-массива над очередью-списком
  PUSH: 49 %
  POP: 85 %
\end{minted}


\subsubsection{Сравнение потребления памяти очереди-массива и очереди-списка}

\textbf{Входные данные: }
4 $\rightarrow$ 6000

\textbf{T1: }
---

\textbf{T2: }
---

\textbf{T3: }
---

\textbf{T4: }
---


\textbf{Результат: }
\begin{minted}{text}
Для 6000 элементов.
Очередь-массив
  Объем занимаемой памяти: 320024 B

Очередь-список
  Объем занимаемой памяти: 144024 B

Преимущество очереди-списка над очередью-массивом
  Объем памяти: 122 %
\end{minted}


\section{Оценка эффективности}
\subsection{Объем занимаемой памяти}


\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер} &  \textbf{Список, Б} & \textbf{Массив, Б} & \textbf{Преимущество списка, \%} \\ \hline

200 & 4824 & 320024 & 6534 \\ \hline
400 & 9624 & 320024 & 3225 \\ \hline
600 & 14424 & 320024 & 2119 \\ \hline
800 & 19224 & 320024 & 1565 \\ \hline
1000 & 24024 & 320024 & 1232 \\ \hline
2000 & 48024 & 320024 & 566 \\ \hline
4000 & 96024 & 320024 & 233 \\ \hline
8000 & 192024 & 320024 & 67 \\ \hline
\textbf{13300} & \textbf{319224} & \textbf{320023} & \textbf{0} \\ \hline
20000 & 480024 & 320024 & -33 \\ \hline

\end{tabular}

\subsection{Скорость операций}

\subsubsection{Push}

\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер}  & \textbf{Массив, мкс} & \textbf{Список, мкс} & \textbf{Преимущество массива, \%} \\ \hline

200 & 7 & 7 & 0 \\ \hline
400 & 13 & 11 & -15 \\ \hline
600 & 18 & 15 & -17 \\ \hline
800 & 23 & 18 & -22 \\ \hline
1000 & 27 & 23 & -15 \\ \hline
2000 & 43 & 47 & 9 \\ \hline
4000 & 70 & 94 & 34 \\ \hline
8000 & 122 & 192 & 57 \\ \hline
20000 & 280 & 487 & 74 \\ \hline

\end{tabular}

\subsubsection{Pop}

\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер}  & \textbf{Массив, мкс} & \textbf{Список, мкс} & \textbf{Преимущество массива, \%} \\ \hline

200 & 5 & 5 & 0 \\ \hline
400 & 9 & 9 & 0 \\ \hline
600 & 11 & 14 & 27 \\ \hline
800 & 13 & 18 & 38 \\ \hline
1000 & 15 & 23 & 53 \\ \hline
2000 & 27 & 61 & 126 \\ \hline
4000 & 38 & 96 & 153 \\ \hline
8000 & 106 & 195 & 84 \\ \hline
20000 & 269 & 492 & 83 \\ \hline

\end{tabular}

\newpage


\section{Контрольные вопросы}
\subsection{Что такое FIFO и LIFO?}

FIFO (first in, first out) --- принцип работы, при котором элементы, помещенные в некоторую структуру первыми, первыми и будут оттуда извлечены. Этот принцип лежит в основе очереди.

LIFO (last in, first out) --- принцип работы, при котором элементы, помещенные в некоторую структуру последними, будут извлечены оттуда первыми. Этот принцип лежит в основе стека.

\subsection{Каким образом, и какой объем памяти выделяется под хранение очереди при различной ее реализации?}

\subsubsection{Реализация в виде массива}
При реализации в виде статического массива, элементы очереди располагаются в статическом сегменте памяти. Под хранение такой очереди выделяется $2 \times sizeof(type *) + sizeof(size\_t) + N \times sizeof(type)$ памяти, где $N$ --- фиксированное максимальное количество элементов очереди.

\subsubsection{Реализация в виде списка}
При реализации в виде списка, элементы очереди располагаются в куче, и размер не должен быть известен заранее. Под хранение такой очереди выделяется $2 \times sizeof(node *) + sizeof(size\_t) + n \times sizeof(node)$ памяти, где $n$ --- количество элементов очереди, $node$ --- узел списка. Под один узел выделяется $sizeof(node *) + sizeof(int)$ памяти.

\subsection{Каким образом освобождается память при удалении элемента из очереди при ее различной реализации?}

\subsubsection{Реализация в виде массива}
При реализации в виде статического массива, элементы очереди при удалении не освобождаются, происходит лишь сдвиг указателя с удаляемого элемента на следующий элемент очереди.

\subsubsection{Реализация в виде списка}
При реализации в виде списка, элементы очереди при удалении освобождаются.


\subsection{Что происходит с элементами очереди при ее просмотре?}

Они удаляются.

\subsection{От чего зависит эффективность физической реализации очереди?}

Эффективность физической реализации очереди зависит от частоты добавления/удаления элементов и изменения размеров очереди.

\subsection{Каковы достоинства и недостатки различных реализаций очереди в зависимости от выполняемых над ней операций?}

\subsubsection{Реализация в виде массива}
\begin{itemize}
	\item[$+$] высокая скорость;
	\item[$+$] простота управления памятью;
	\item[$-$] относительная сложность реализации;
	\item[$-$] так как массив неразрывен, то размер блока очереди физически более ограничен;
	\item[$-$] неэффективное потребление памяти, когда выделено сильно больше, чем используется.
\end{itemize}

\subsubsection{Реализация в виде списка}
\begin{itemize}
	\item[$+$] относительно высокая скорость;
	\item[$+$] более эффективное потребление памяти;
	\item[$+$] простота и удобство обработки;
	\item[$-$] необходимость ручного освобождения;
	\item[$-$] медленнее, чем реализация массивом;
	\item[$-$] если размер близок к граничным размерам массива, то становится неэффективной по памяти.
\end{itemize}


\subsection{Что такое фрагментация памяти?}

Фрагментация --- дробление памяти на несмежные свободные фрагменты.

\subsection{Для чего нужен алгоритм <<близнецов>>?}

За счет распределения свободных блоков по степеням двойки, поиск области памяти нужного размера осуществляется гораздо быстрее. Если найден блок в два и более раз большего размера, то он просто делится надвое, то есть блоки всегда остаются распределенными по степеням двойки. При возникновении подходящих блоков, они могут быть слиты в один большой блок размером степени двойки.

Таким образом, алгоритм <<близнецов>> позволяет быстрее искать нужные области памяти, а также оптимально объединять разделенные блоки памяти.

\subsection{Какие дисциплины выделения памяти вы знаете?}

\begin{itemize}
	\item[$*$] <<первый подходящий>> --- выбирается первый подходящий по размеру блок. Соотвественно, он может быть сильно больше необходимого размера;
	\item[$*$] <<самый подходящий>> --- выбирается либо блок такого же размера, какого было запрошено, либо превышающий его на минимальную величину.
\end{itemize}

\subsection{На что необходимо обратить внимание при тестировании программы?}

На работу с динамическими ресурсами, переполнение очереди и фрагментацию памяти.

\subsection{Каким образом физически выделяется и освобождается память при динамических запросах?}

При динамическом распределении памяти объекты размещаются в <<куче>>.

При формировании объекта указывается размер запрашиваемой под объект памяти, и, в случае успеха, выделенная область памяти, становится недоступной при последующих операциях выделения памяти. 

Освобождаемая память возвращается в <<кучу>> и становится доступной при дальнейших операциях выделения памяти.

\newpage

\section{Вывод}

Реализация очереди в виде списка эффективнее по памяти, когда заполненность меньше того размеры, который выделен под статический массив. В то же время, при большой заполненности очереди, массив оказывается эффективнее. При выделенном объеме для статического массива в $20 000$ элементов, преимущество по памяти для списка упало с $6534 \%$ при размере очереди $200$ элементов, до нуля при $13 300$ элементах в очереди.

Стоит отметить, что выделение памяти под список более гарантированно, так как проще найти много маленьких блоков памяти, чем один большой.

При тестировании не было обнаружено фрагментации памяти, и это хорошо, так как у фрагментации нет преимуществ, дефрагментация может позволить быстрее получать доступ к данным. Однако, для пользователя разница в работе с фрагментированными и дефрагментированными данными вряд ли будет наблюдаться, так как операционная система предоставляет необходимый интерфейс.

В плане скорости, реализация очереди массивом показала преимущество относительно реализации списком до $74 \%$ по операции <<push>>, и до $153 \%$ по операции <<pop>>. Из-за накладных расходов и особенностей архитектуры компьютера, на котором производилось тестирование, данные немного смазаны: именно поэтому на небольших данных список оказывается ощутимо быстрее массива на операции <<push>>.

\newpage
\begin{thebibliography}{2}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{method}
Методические рекомендации по лабораторной работе №5 (\emph{http://wwwcdl.bmstu.ru/}) 
\end{thebibliography}

\end{document}
