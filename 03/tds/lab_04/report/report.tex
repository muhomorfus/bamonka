\documentclass[a4paper,12pt]{extarticle}
%Gummi|065|=)
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[left=3cm,right=1.5cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{amsmath}
\usepackage{caption}
% \usepackage{color}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{verbatimbox}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{indentfirst}
\usepackage{alltt}

\usepackage[cache=false]{minted}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%

\linespread{1.3}
\begin{document}

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА

    \begin{table}[h!]
     \begin{center}
     \begin{tabular}{  c  p{0.8\textwidth}  }
     \raisebox{-\totalheight}{\includegraphics[width=0.15\textwidth, height=30mm]{bmstu.png}}
      & 
      \begin{center}
          Министерство образования и науки Российской Федерации \\
      Федеральное государственное бюджетное образовательное учреждение высшего образования  \\
    
      «Московский государственный технический университет \\
      имени Н.Э. Баумана» \\
    
      (МГТУ им. Н.Э. Баумана)
      \end{center}
      \\
      \hline
      \end{tabular}
      \end{center}
\end{table}

\textbf{ }
\\
\textbf{ФАКУЛЬТЕТ: } \underline{Информатика и системы управления}
\\
\textbf{КАФЕДРА: } \underline{Программное обеспечение ЭВМ и информационные технологии}
\\
\textbf{ДИСЦИПЛИНА: } \underline{Типы и структуры данных}
\\
\textbf{ТЕМА: } \underline{Работа со стеком}
\\
\textbf{ВАРИАНТ: } \underline{3}

\vspace{1cm}

\begin{center}
    \large{\textbf{\underline{ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ №4}}}
\end{center}

\textbf{ }
\vspace{1cm}
\\
\textbf{Студент: } \hspace{5.2cm} \underset{\text{(подпись, дата)}}{\underline{\hspace{0.3\textwidth}}} \textit{ Княжев А. В. }
\vspace{0.2cm}
\\
\textbf{Преподаватель: } \hspace{4cm} \underset{\text{(подпись, дата)}}{\underline{\hspace{0.3\textwidth}}} \textit{ Силантьева А. В. }

\vspace{7cm}
\begin{center} \textit{2021 г.} \end{center}
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Условие задачи}
Элементами стека являются слова. Распечатайте слова в обратном порядке в перевернутом виде.

\newpage

\section{Техническое задание}
Разработать программу работы со стеком, реализующую операции добавления и удаления элементов из стека и отображения текущего состояния стека. Реализовать стек: 

\begin{itemize}
	\item[$*$] массивом;
	\item[$*$] списком.
\end{itemize}

Все стандартные операции со стеком должны быть оформлены отдельными подпрограммами. В случае реализации стека в виде списка при отображении текущего состояния стека предусмотреть возможность просмотра адресов элементов стека и создания дополнительного собственного списка свободных областей (адресов освобождаемой памяти при удалении элемента, который можно реализовать как списком, так и массивом) с выводом его на экран. Список свободных областей необходим для того, чтобы проследить, каким образом происходит выделение памяти менеджером памяти при запросах на нее и убедиться в возникновении или отсутствии фрагментации памяти.

Сравнить эффективность (по памяти и по времени выполнения) обработки стека списком и массивом.

Программа должна выводить меню с возможностью выбирать варианты. При вводе нуля на запрос варианта меню, происходит выход из программы.

\subsection{Общие входные данные}
\begin{itemize}
    \item[$*$] номер выбранного пункта меню.
\end{itemize}

\subsection{Входные и выходные данные пунктов меню}
\subsubsection{Добавление элемента в стек-массив}


\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] строка (длиной до 256 символов), добавляемая в стек.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] сообщение об успешности добавления.
\end{itemize}

\subsubsection{Добавление элемента в стек-список}


\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] строка (длиной до 256 символов), добавляемая в стек.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] сообщение об успешности добавления.
\end{itemize}

\subsubsection{Удаление элемента из стека-массива}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] значение удаленной строки.
\end{itemize}


\subsubsection{Удаление элемента из стека-списка}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] значение удаленной строки.
\end{itemize}


\subsubsection{Вывод перевернутых строк в обратном порядке из стека-массива}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] список перевернутых строк, в обратном порядке относительно добавления, которые были в стеке.
\end{itemize}


\subsubsection{Вывод перевернутых строк в обратном порядке из стека-списка}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] список перевернутых строк, в обратном порядке относительно добавления, которые были в стеке.
\end{itemize}


\subsubsection{Вывод состояния стека-массива}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] список строк, хранящихся в стеке (сверху те, что были добавлены последними).
\end{itemize}


\subsubsection{Вывод состояния стека-списка}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] список строк, хранящихся в стеке (сверху те, что были добавлены последними);
    \item[$*$] для каждого элемента адрес элемента стека-списка.
\end{itemize}


\subsubsection{Вывод списка свободных областей для стека-списка}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] список адресов областей, освобожденных в результате удаления элементов из стека-списка.
\end{itemize}


\subsubsection{Сравнение скорости работы стеков двух типов}


\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] количество элементов.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] скорости работы добавления и удаления введенного количества элементов для каждого вида стека и их сравнения.
\end{itemize}


\subsubsection{Сравнение объема занимаемой памяти стеков двух типов}


\paragraph{Входные данные}
\begin{itemize}
    \item[$*$] количество элементов.
\end{itemize}

\paragraph{Выходные данные}
\begin{itemize}
    \item[$*$] объемы занимаемой памяти стеков с указанным количеством элементов и их сравнение.
\end{itemize}


\subsection{Действие программы}
Программа осуществляет работу со стеками в формате массива и списка.

\subsection{Обращение к программе}
Программа может быть запущена из командных оболочек \texttt{sh/bash/zsh/fish}, а также от IDE, способных работать с языком Си. Программа не принимает никаких аргументов.

\subsection{Аварийные ситуации}
\subsubsection{Общие аварийные ситуации}
\begin{enumerate}
    \item невалидный номер пункта меню (строка или пустая строка);
    \item неверный номер пункта меню (такого пунта меню не существует).
\end{enumerate}

\subsubsection{Пункт меню №1}
\begin{enumerate}
    \item введена пустая строка;
    \item введена строка длиной больше 256 символов.
\end{enumerate}

\subsubsection{Пункт меню №2}
\begin{enumerate}
    \item введена пустая строка;
    \item введена строка длиной больше 256 символов.
\end{enumerate}

\subsubsection{Пункт меню №3}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №4}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №5}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №6}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №7}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №8}
\begin{enumerate}
    \item стек пуст.
\end{enumerate}

\subsubsection{Пункт меню №9}

\subsubsection{Пункт меню №10}
\begin{enumerate}
    \item слишком большое количество элементов;
    \item слишком маленькое количество элементов;
    \item невалидное количество элементов.
\end{enumerate}

\subsubsection{Пункт меню №11}
\begin{enumerate}
    \item слишком большое количество элементов;
    \item слишком маленькое количество элементов;
    \item невалидное количество элементов.
\end{enumerate}

\newpage

\section{Структуры данных}
В данной работе используется статичесике массивы, записи и односвязные списки.

\subsection{Модуль для работы с ошибками}
\subsubsection{Типы данных}
\begin{minted}{C}
/*
 * text - текст ошибки;
 * code - код ошибки;
 * func - функция, в которой случилась ошибка.
 */
typedef struct 
{
    const char *text;
    int code;
    const char *func;
} error_t;
\end{minted}


\subsubsection{Функции}
\begin{minted}{C}
/*
 * Создание новой ошибки.
 * text - текст ошибки;
 * code - код ошибки;
 * func - функция, в которой случилась ошибка.
 */
error_t new_error(const char *text, int code, const char *func);
\end{minted}


\begin{minted}{C}
/*
 * Создание ошибки-маркера успеха.
 * func - функция, в которой был создан "успех".
 */
error_t new_success(const char *func);
\end{minted}



\begin{minted}{C}
/*
 * Проверка, отображает ли ошибка ошибочную ситуацию.
 * err - исходная ошибка.
 */
bool is_failure(error_t err);
\end{minted}


\subsection{Модуль для работы со строками}
\subsubsection{Основные константы}
\begin{minted}{C}
/*
 * Тип строки длиной 256 символов + терминальный нуль.
 */
typedef char mystring_t[MYSTRING_SIZE];
\end{minted}


\subsubsection{Типы данных}
\begin{minted}{C}
/*
 * Тип строки длиной 256 символов + терминальный нуль.
 */
typedef char mystring_t[MYSTRING_SIZE];
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/*
 * Чтение строки из файла.
 * f - файл;
 * str - строка, в которую считываем.
 */
error_t f_read_line(FILE *f, mystring_t str);
\end{minted}

\begin{minted}{C}
/*
 * Чтение целого числа из стандартного потока ввода.
 * n - считываемое число.
 */
error_t read_int(int *n);
\end{minted}

\begin{minted}{C}
/*
 * Переворачивает строку.
 * str - исходная строка.
 */
error_t reverse(char *str);
\end{minted}

\subsection{Модуль для работы со списком указателей}
\subsubsection{Типы данных}
\begin{minted}{C}
/*
 * Список указателей.
 * content - указатель (содержимое элемента);
 * next - указатель на следующий элемент.
 */
typedef struct ptr_list_t ptr_list_t;
struct ptr_list_t
{
    void *content;
    ptr_list_t *next;
};
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/*
 * Добавление элемента в список.
 * head - голова списка;
 * ptr - добавляемый указатель.
 */
error_t pl_add(ptr_list_t **head, void *ptr);
\end{minted}

\begin{minted}{C}
/*
 * Удаление указателя.
 * head - голова списка;
 * ptr - удаляемый указатель.
 */
error_t pl_delete(ptr_list_t **head, void *ptr);
\end{minted}

\begin{minted}{C}
/*
 * Вывод элементов списка.
 * head - голова списка.
 */
error_t pl_print(ptr_list_t **head);
\end{minted}

\begin{minted}{C}
/*
 * Освобождение списка.
 * head - голова списка.
 */
void pl_free(ptr_list_t **head);
\end{minted}

\subsection{Модуль <<ядра>> программы}
\subsubsection{Функции}
\begin{minted}{C}
/*
 * Запуск основного диалога программы.
 */
error_t eng_work();
\end{minted}

\subsection{Модуль для тестирования скорости работы}
\subsubsection{Основные константы}
\begin{minted}{C}
/*
 * Количество запусков тестов производительности.
 */
#define BENCH_NUM_OF_RUNS 10000
\end{minted}

\subsubsection{Функции}
\begin{minted}{C}
/*
 * Получение скорости n операций "push" для стека-массива.
 * n - количество элементов;
 * timer - среднее время.
 */
error_t bench_stack_arr_push(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/*
 * Получение скорости n операций "pop" для стека-массива.
 * n - количество элементов;
 * timer - среднее время.
 */
error_t bench_stack_arr_pop(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/*
 * Получение скорости n операций "push" для стека-списка.
 * n - количество элементов;
 * timer - среднее время.
 */
error_t bench_stack_list_push(size_t n, long long *timer);
\end{minted}

\begin{minted}{C}
/*
 * Получение скорости n операций "pop" для стека-списка.
 * n - количество элементов;
 * timer - среднее время.
 */
error_t bench_stack_list_pop(size_t n, long long *timer);
\end{minted}

\subsection{Модуль для работы со стеком-массивом}
\subsubsection{Основные константы}
\begin{minted}{C}
/*
 * Максимальное количество элементов стека-массива.
 */
#define SA_STACK_SIZE 5000
\end{minted}

\subsubsection{Типы данных}

\begin{minted}{C}
/*
 * Стек-массив.
 * content - содержимое стека;
 * ptr - указатель на место, в которое вставлять очередной
 *       элемент стека.
 */
typedef struct stack_arr_t
{
    mystring_t content[SA_STACK_SIZE];
    mystring_t *ptr;
} stack_array_t;
\end{minted}

\subsubsection{Функции}

\begin{minted}{C}
/*
 * Создание пустого стека.
 */
stack_array_t sa_create();
\end{minted}

\begin{minted}{C}
/*
 * Добавление элемента в стек.
 * sa - исходный стек;
 * str - добавляемая строка.
 */
error_t sa_push(stack_array_t *sa, mystring_t str);
\end{minted}

\begin{minted}{C}
/*
 * Удаление элемента из стека.
 * sa - исходный стек;
 * str - значение удаленной строки.
 */
error_t sa_pop(stack_array_t *sa, mystring_t str);
\end{minted}

\begin{minted}{C}
/*
 * Проверка стека на пустоту.
 * sa - исходный стек.
 */
bool sa_empty(stack_array_t *sa);
\end{minted}

\subsection{Модуль для работы со стеком-списком}
\subsubsection{Типы данных}

\begin{minted}{C}
/*
 * Стек-список.
 * content - содержимое элемента стека (строка);
 * next - указатель на следующий элемент стека.
 */
typedef struct stack_list_t stack_list_t;
struct stack_list_t
{
    mystring_t content;
    stack_list_t *next;
};
\end{minted}

\subsubsection{Функции}

\begin{minted}{C}
/*
 * Добавление элемента в стек.
 * sl - исходный стек;
 * str - добавляемая строка.
 */
error_t sl_push(stack_list_t **sl, mystring_t str);
\end{minted}

\begin{minted}{C}
/*
 * Удаление элемента из стека.
 * sl - исходный стек;
 * str - значение удаленной строки.
 */
error_t sl_pop(stack_list_t **sl, mystring_t str);
\end{minted}

\begin{minted}{C}
/*
 * Освобождение стека-списка.
 * sl - исходный стек.
 */
error_t sl_free(stack_list_t **sl);
\end{minted}

\begin{minted}{C}
/*
 * Проверка стека на пустоту.
 * sl - исходный стек.
 */
bool sl_empty(stack_list_t **sl);
\end{minted}



\newpage
\section{Описания алгоритмов}


\begin{enumerate}
    \item вывод главного меню;
    \item получение у пользователя номера пункта меню:
\end{enumerate}

\subsection{Пункт меню №1}
\begin{enumerate}
    \item получить у пользователя строку;
    \item добавить ее в стек-массив.
\end{enumerate}

\subsection{Пункт меню №2}
\begin{enumerate}
    \item получить у пользователя строку;
    \item добавить ее в стек-список.
\end{enumerate}

\subsection{Пункт меню №3}
\begin{enumerate}
    \item удалить элемент из стека-массива;
    \item вывести удаленный элемент.
\end{enumerate}

\subsection{Пункт меню №4}
\begin{enumerate}
    \item удалить элемент из стека-списка;
    \item добавить адрес удаленного элемента в список свободных областей;
    \item вывести удаленный элемент.
\end{enumerate}

\subsection{Пункт меню №5}
\begin{enumerate}
    \item пока стек-массив не пуст:
    \begin{enumerate}
    	\item вытащить элемент из стека-массива;
    	\item перевернуть этот элемент (как строку);
    	\item вывести перевернутую строку на экран.
    \end{enumerate}
\end{enumerate}

\subsection{Пункт меню №6}
\begin{enumerate}
    \item пока стек-список не пуст:
    \begin{enumerate}
    	\item вытащить элемент из стека-списка;
    	\item перевернуть этот элемент (как строку);
    	\item вывести перевернутую строку на экран.
    \end{enumerate}
\end{enumerate}

\subsection{Пункт меню №7}
\begin{enumerate}
    \item вывести список элементов стека-массива.
\end{enumerate}

\subsection{Пункт меню №8}
\begin{enumerate}
    \item вывести список элементов стека-списка с адресами.
\end{enumerate}

\subsection{Пункт меню №9}
\begin{enumerate}
    \item вывести список свободных областей (адресов в памяти, которые были получены после удаления очередных элементов из стека-списка и пока не заняты).
\end{enumerate}

\subsection{Пункт меню №10}
\begin{enumerate}
    \item получить у пользователя количество элементов;
    \item для каждого вида стека посчитать среднюю скорость добавления и удаления введенного количества элементов и вывести на экран;
    \item вывести процентное превосходство скорости работы стека-массива над стеком-списоком.
\end{enumerate}

\subsection{Пункт меню №11}
\begin{enumerate}
    \item получить у пользователя количество элементов;
    \item для каждого вида стека посчитать количество памяти, затрачиваемое для хранения введенного количества элементов;
    \item вывести процентное превосходство объема занимаемой памяти стека-списка над списком-массивом.
\end{enumerate}

\newpage

\section{Тестирование}
Для проверок корректности работы программы было проведено функциональное тестирование. Таблица с тестовыми данными для <<позитивных>> и <<негативных>> случаев приведена ниже.

Так как входных/выходных данных может быть очень много, то в соответствующих полях могут быть указаны наиболее значимые части.

\subsection{<<Негативные>> тесты}
\subsubsection{Ввод невалидного пункта меню}

\textbf{Входные данные: }
abc

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
104: Строка не является корректным числом (to\_integer)

% ---

\subsubsection{Ввод некорректного пункта меню}

\textbf{Входные данные: }
12

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
161: введен неверный пункт меню (main\_menu\_dialog)

% ---

\subsubsection{Ввод слишком длинной строки}

\textbf{Входные данные: }
1 $\rightarrow$ \textit{<строка из 300 символов>} или 2 $\rightarrow$ \textit{<строка из 300 символов>}

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
103: Считанная строка слишком длинная (f\_read\_line)

% ---

\subsubsection{Удаление элемента из пустого стека}

\textbf{Входные данные: }
3 или 4

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
101: стек пуст (sa\_pop) или 122: стек пуст (sl\_pop)

% ---

\subsubsection{Вывод перевернутых слов из пустого стека}

\textbf{Входные данные: }
5 или 6

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
140: стек-массив пуст (sa\_print\_reversed) или 140: стек-список пуст (sl\_print\_reversed)

% ---

\subsubsection{Вывод состояния пустого стека}

\textbf{Входные данные: }
7 или 8

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
140: стек-массив пуст (sa\_print\_state) или 140: стек-список пуст (sl\_print\_state)

% ---

\subsubsection{Ввод невалидного количества элементов}

\textbf{Входные данные: }
10 $\rightarrow$ abc или 11 $\rightarrow$ abc

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
104: Строка не является корректным числом (to\_integer)

% ---

\subsubsection{Ввод слишком большого количества элементов}

\textbf{Входные данные: }
10 $\rightarrow$ 100000 или 11 $\rightarrow$ 100000

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
100: слишком большой размер (eng\_work)

% ---

\subsubsection{Ввод слишком маленького количества элементов}

\textbf{Входные данные: }
10 $\rightarrow$ -2 или 11 $\rightarrow$ -2

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
161: неверное количество элементов стека (eng\_work)

% ---

\subsubsection{Переполнение стека-массива}

\textbf{Входные данные: }
1 $\rightarrow$ one

\textbf{Стек-массив: }
стек с максимальным количеством элементов

\textbf{Стек-список: }
---

\textbf{Результат: }
100: переполнение стека (sa\_push)


\subsection{<<Позитивные>> тесты}

\subsubsection{Добавление элемента в стек-массив}

\textbf{Входные данные: }
1 $\rightarrow$ one

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
Строка успешно добавлена.

\subsubsection{Добавление элемента в стек-список}

\textbf{Входные данные: }
2 $\rightarrow$ two

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }
Строка успешно добавлена.

\subsubsection{Удаление элемента из стека-массива}

\textbf{Входные данные: }
3

\textbf{Стек-массив: }
[hello, one]

\textbf{Стек-список: }
---

\textbf{Результат: }
Удаленная строка: "hello"

\subsubsection{Удаление элемента из стека-списка}

\textbf{Входные данные: }
4

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
[four, three, two]

\textbf{Результат: }
Удаленная строка: "four"

\subsubsection{Вывод состояния стека-массива}

\textbf{Входные данные: }
7

\textbf{Стек-массив: }
[hello, world, my, name, is, alex]

\textbf{Стек-список: }
---

\textbf{Результат: }

\begin{minted}{text}
Состояние стека-массива:
"hello"
"world"
"my"
"name"
"is"
"alex"	
\end{minted}

\subsubsection{Вывод перевернутых строк в обратном порядке из стека-массива}

\textbf{Входные данные: }
5

\textbf{Стек-массив: }
[hello, world, my, name, is, alex]

\textbf{Стек-список: }
---

\textbf{Результат: }

\begin{minted}{text}
"olleh"
"dlrow"
"ym"
"eman"
"si"
"xela"
\end{minted}

\subsubsection{Вывод состояния стека-списка}

\textbf{Входные данные: }
8

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
[five, four, three, two, one]

\textbf{Результат: }

\begin{minted}{text}
Состояние стека-списка:
0x14b004190 "five"
0x14b104080 "four"
0x14b004080 "three"
0x149f04190 "two"
0x149f04080 "one"
\end{minted}

\subsubsection{Вывод перевернутых строк в обратном порядке из стека-списка}

\textbf{Входные данные: }
6

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
[five, four, three, two, one]

\textbf{Результат: }

\begin{minted}{text}
"evif"
"ruof"
"eerht"
"owt"
"eno"
\end{minted}

\subsubsection{Вывод списка свободных областей}

\textbf{Входные данные: }
9

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }

\begin{minted}{text}
Список свободных областей для стека-списка:
0x14b1044c0
0x14b1043b0
0x14b1042a0
0x14b104080
0x14b104190
0x149f04080
0x149f04190
0x14b004080
0x14b004190
\end{minted}

\subsubsection{Сравнение стеков по скорости}

\textbf{Входные данные: }
10 $\rightarrow$ 1000

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }

\begin{minted}{text}
Для 10000 запусков и 1000 элементов.
Стек-массив
  PUSH: 16 us
  POP: 15 us
Стек-список
  PUSH: 37 us
  POP: 37 us

Преимущество стека-массива над стеком-списком
  PUSH: 131 %
  POP: 147 %
\end{minted}

\subsubsection{Сравнение стеков по памяти}

\textbf{Входные данные: }
11 $\rightarrow$ 1000

\textbf{Стек-массив: }
---

\textbf{Стек-список: }
---

\textbf{Результат: }

\begin{minted}{text}
Для 1000 элементов.
Стек-массив
  Объем занимаемой памяти: 1285008 B

Стек-список
  Объем занимаемой памяти: 272000 B

Преимущество стека-списка над стеком-массивом
  Объем памяти: 372 %
\end{minted}

\newpage

\section{Оценка эффективности}
\subsection{Объем занимаемой памяти}


\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер} &  \textbf{Список, Б} & \textbf{Массив, Б} & \textbf{Преимущество списка, \%} \\ \hline

50 & 13600 & 1285008 & 9349 \\ \hline
100 & 27200 & 1285008 & 4624 \\ \hline
200 & 54400 & 1285008 & 2262 \\ \hline
400 & 108800 & 1285008 & 1081 \\ \hline
800 & 217600 & 1285008 & 491 \\ \hline
1600 & 435200 & 1285008 & 195 \\ \hline
3200 & 870400 & 1285008 & 48 \\ \hline
5000 & 1360000 & 1285008 & -6 \\ \hline

\end{tabular}

\subsection{Скорость операций}

\subsubsection{Push}

\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер}  & \textbf{Массив, мкс} & \textbf{Список, мкс} & \textbf{Преимущество массива, \%} \\ \hline

50 & 2 & 2 & 0 \\ \hline
100 & 3 & 5 & 67 \\ \hline
200 & 7 & 8 & 14 \\ \hline
400 & 14 & 15 & 7 \\ \hline
800 & 24 & 29 & 21 \\ \hline
1600 & 40 & 58 & 45 \\ \hline
3200 & 66 & 123 & 86 \\ \hline
5000 & 94 & 207 & 120 \\ \hline
10000 & 163 & 478 & 193 \\ \hline

\end{tabular}

\subsubsection{Pop}

\begin{tabular}{ |l|r|r|l| }
\hline
\textbf{Размер}  & \textbf{Массив, мкс} & \textbf{Список, мкс} & \textbf{Преимущество массива, \%} \\ \hline

50 & 1 & 2 & 100 \\ \hline
100 & 2 & 4 & 100 \\ \hline
200 & 4 & 8 & 100 \\ \hline
400 & 8 & 15 & 88 \\ \hline
800 & 13 & 30 & 131 \\ \hline
1600 & 24 & 60 & 150 \\ \hline
3200 & 48 & 122 & 154 \\ \hline
5000 & 75 & 209 & 179 \\ \hline
10000 & 154 & 401 & 160 \\ \hline

\end{tabular}

\newpage


\section{Контрольные вопросы}
\subsection{Что такое стек?}
Стек --- это последовательный список с переменной длиной, в котором включение и исключение элементов происходит только с одной стороны --- с его вершины. Стек функционирует по принципу: последним пришел --- первым ушел, Last In – First Out (LIFO).

\subsection{Каким образом и сколько памяти выделяется под хранение стека при различной его реализации?}

При хранении стека, как списка, память выделяется в куче, при этом памяти выделяется именно столько, сколько сейчас элементов в стеке. С каждым элементом стека, хранится указатель на следующий элемент, что увеличивает объем памяти.

При хранении стека, как статического массива, память выделяется на стеке, ее выделяется какое-то изначально заданное количество (под 5000, 10000 элементов, и т. д.). Кроме самих элементов, в этом случае, необходимо хранить указатель на текущий элемент стека.

\subsection{Каким образом освобождается память при удалении элемента стека при различной реализации стека?}

При хранении стека, как списка происходит освобождение верхнего элемента и сдвиг указателя на следующий.

При хранении стека, как массива, происходит сдвиг указателя к следующему элементу.

\subsection{Что происходит с элементами стека при его просмотре?}

Элементы удаляются.

\subsection{Каким образом эффективнее реализовывать стек? От чего это зависит?}

Если наиболее важна скорость обработки, и не так важен объем занимаемой памяти, то целесообразнее использовать реализацию стека в виде массива. 

Иначе, целесообразнее использовать реализацию стека в виде списка, так как в этом случае занимаемый объем памяти соответствует количеству элементов в стеке, а также элементы стека не обязаны располагаться в памяти друг за другом, то есть увеличивается <<надежность>> выделения памяти: проще найти несколько разделенных маленьких фрагментов памяти, чем искать один большой цельный кусок.

\newpage

\section{Вывод}
По памяти на небольших размерах эффективнее использовать стек-список, чем стек-статический массив, так как размер списка зависит только от количества его текущих элементов. Однако, на больших размерах, близких к максимальному размеру стека-массива, массив начинает быть более эффективным, так как массив хранит в себе только сами элементы, а список же содержит еще и дополнительную информацию, такую как указатель на следующий элемент. Преимущество по памяти у стека-списка снижается с 9349 \% на 50 элементах, до -6 \% на 5000 элементах.

По времени эффективнее использовать стек-массив, так как операция <<push>> для списка несет в себе выделение памяти, а <<pop>> --- освобождение. Эти операции являются довольно долгими, поэтому такие операции менее эффективны, по сравнению с простым сдвигом указателя в стеке-массиве. Преимущество по скорости у стека-массива варьируется от 0 до 193 \% для операции <<push>> и от 88 до 179 \% для операции <<pop>>.

В ходе тестирования программы было обнаружено, что иногда происходит фрагментация данных. Это плохо, так как преимуществ у фрагментации нет. Преимуществами дефрагментации данных являются более высокая скорость и простота доступа к данным. Так как операционная система предоставляет нам необходимый интерфейс, то работа с фрагментарованными и дефрагментированными данными для пользователя одинакова.


\newpage
\begin{thebibliography}{2}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{method}
Методические рекомендации по лабораторной работе №4 (\emph{http://wwwcdl.bmstu.ru/}) 
\end{thebibliography}

\end{document}
