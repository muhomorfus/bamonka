\section{Пересчет динамических приоритетов}

В операционных системах семейства UNIX и Windows пересчитываться могут только приоритеты пользовательских процессов. 

\subsection{UNIX}

Планирование процессов в $UNIX$ основано на приоритете процесса. Планировщик всегда выбирает процесс с наивысшим приоритетом. Приоритеты планирования пользовательских процессов изменяются с течением времени, то есть динамически системой, в зависимости от использования вычислительных ресурсов, времени ожидания запуска и текущего состояния процесса. 

%todo
UNIX --- это многопоточная система. Единицей диспетчеризации является поток.  

В современных системах UNIX ядро использует принцип Round-robin, обслуживая процессы с равным приоритетом. Ядро является преемптивным. Это означает, что процесс ядра может быть вытеснен при появлении процесса в большим приоритетом. %Это сделано, чтобы система могла обслуживать процессы реального времени, например видео и аудио.

При создании процессов ему назначается приоритет. Потоки получают приоритет относительно базового приоритета процесса. 

Очередь процессов, готовых к выполнению, формируется согласно приоритетам и принципу вытесняющего циклического планирования, то есть сначала выполняются процессы с большим приоритетом, а процессы с одинаковым приоритетом выполняются в течение выделенного им кванта времени друг за другом циклически. В случае, если процесс с более высоким приоритетом поступает в очередь процессов, готовых к выполнению, планировщик вытесняет текущий процесс и предоставляет ресурс более приоритетному процессу.

Приоритет процесса задается любым целым числом, которое лежит в диапазоне от 0 до 127 по правилу <<чем меньше число, тем выше приоритет>>. При этом числа в диапазона от 0 до 49 являются зарезервированными для ядра, то есть они фиксированы и зависят от причины засыпания ядра. Числа в диапазоне от 50 до 127 являются приоритетами прикладных задач (приоритеты которых могут изменяться во времени).

Дескриптор процесса UNIX BSD struct proc содержит следующие поля, которые относятся к приоритетам:
\begin{itemize}
	\item p\_pri -- текущий приоритет планирования
	\item p\_usrpri -- приоритет режима задачи
	\item p\_cpu -- результат последнего измерения использования процессора
	\item p\_nice -- фактор <<любезности>>, который устанавливается пользователем
\end{itemize}

\textbf{p\_pri} используется планировщиком для принятия решения о том, какой процесс отправить на выполнение. 

\textbf{p\_pri} и \textbf{p\_usrpri} равны, когда процесс находится в режиме задачи. 

Значение \textbf{p\_pri} может быть изменено (повышено) планировщиком для того, чтобы выполнить процесс в режиме ядра. В таком случае \textbf{p\_usrpri} будет использоваться для хранения приоритета, который будет назначен процессу, когда тот вернется в режим задачи.

\textbf{p\_cpu} инициализируется нулем при создании процесса (и на каждом тике обработчик таймера увеличивает это поле на 1, до максимального значения равного 127).

\subsubsection{Статические приоритеты}

Как сказано выше, числа в диапазоне 0--49 соответствуют приоритету процесса, зарезервированного для ядра. 

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может блокироваться. Когда процесс <<просыпается>>, ядро устанавливает \textbf{p\_pri}, равное приоритету сна события или ресурса, по которому произошла блокировка. 

В таблице~\ref{tab:bsd} приведены значения приоритета сна для некоторых событий в системе BSD.

\begin{table}[!h]
	\begin{center}
		\caption{Приоритеты сна в операционной системе \textbf{4.3BSD}}
		\label{tab:bsd}
		\begin{tabular}{ |c|c|c|  }
			\hline
			\textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\
			\hline
			\texttt{PSWP} & 0 & Свопинг \\
			\hline
			\texttt{PSWP + 1} & 1 & Страничный демон \\
			\hline
			\texttt{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
			\hline
			\texttt{PINOD} & 10 & Ожидание освобождения inode \\
			\hline
			\texttt{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
			\hline
			\texttt{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
			\hline
			\texttt{PZERO} & 25 & Базовый приоритет \\
			\hline
			\texttt{TTIPRI} & 28 & Ожидание ввода с терминала \\
			\hline
			\texttt{TTOPRI} & 29 & Ожидание вывода с терминала \\
			\hline 
			\texttt{PWAIT} & 30 & Ожидание завершения процесса потомка \\
			\hline
			\texttt{PLOCK} & 35 & Консультативное ожидание блок. ресурса \\
			\hline
			\texttt{PSLEP} & 40 & Ожидание сигнала \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

В таблице~\ref{tab:bsd1} приведены значения приоритетов сна для систем 4.3BSD UNIX и SCO UNIX. 
\begin{table}[!h]
	\begin{center}
		\caption{Системные приоритеты сна}
		\label{tab:bsd1}
		\begin{tabular}{ |c|c|c|  }
			\hline
			\thead{\textbf{Событие}} & \thead{Приоритет в\\ \textbf{4.3BSD UNIX}} & \thead{Приоритет в\\ \textbf{SCO UNIX}} \\
			\hline
			\thead{Ожидание загрузки в\\ память страницы} & 0 & 95 \\
			\hline
			\thead{Ожидание индексного\\ дескриптора} & 10 & 88 \\
			\hline
			\thead{Ожидание\\ ввода-вывода} & 20 & 81 \\
			\hline
			\thead{Ожидание буфера} & 30 & 80\\
			\hline
			\thead{Ожидание \\терминального ввода }& 30 & 75 \\
			\hline
			\thead{Ожидание \\терминального вывода }& 30 & 74 \\
			\hline
			\thead{Ожидание \\завершения выполнения }& 30 & 73 \\
			\hline
			\thead{Ожидание события} & 40 & 66 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\subsubsection{Динамические приоритеты}

Изменение приоритета прикладных задач зависит от двух факторов: фактор <<любезности>> и результат последней измеренной величины использования процессора (фактора утилизации).  Фактор <<любезности>> -- целое число в диапазоне от 0 до 39 со значением 20 по умолчанию. Увеличение значения приводит к уменьшению приоритета. Пользователи могут повлиять на приоритет процесса при помощи изменения значений этого фактора, но только суперпользователь может увеличить приоритет процесса. Фоновые процессы автоматически имеют более высокие значения этого фактора.

Обращаясь к ранее описанному дескриптору процесса UNIX BSD struct proc, поле \textbf{p\_cpu} инициализирует отложенный вызов процедуры schedcpu(), которая уменьшает значение \textbf{p\_pri} каждого процесса исходя из фактора <<полураспада>>, в системе 4.3BSD который рассчитывается по формуле (\ref{eq:ref1}).

\begin{equation}
	\label{eq:ref1}
	decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1} ,
\end{equation} где
\textit{load\_average} - это среднее количество процессов, находящихся в состоянии готовности к выполнению, за последнюю секунду.

Также процедура schedcpu() пересчитывает приоритеты для режима задачи всех процессов по формуле (\ref{eq:ref2}).

\begin{equation}
	\label{eq:ref2}
	p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice ,
\end{equation}где \textit{PUSER} - базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс в последний раз использовал большое количество процессорного времени, то его р\_срu будет увеличен, следовательно будет рост значения p\_usrpri и понижение приоритета.  Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор полураспада уменьшает его р\_срu и следовательно повышение его приоритета. 

Такая схема предотвращает бесконечное откладывание низкоприоритетных процессов. Применение данной схемы предпочтительно процессам, осуществляющим много операций ввода-вывода, в противоположность процессам, производящим много вычислений. То есть динамический пересчёт приоритетов низкоприоритетных процессов позволяет избежать бесконечного откладывания.


\subsection{Windows}

В Windows процессу при создании назначается приоритет. Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал. Относительно базового приоритета процесса потоку назначается относительный приоритет. 

Планирование осуществляется только на основании приоритетов потоков, готовых к выполнению: если поток с более высоким приоритетом становится готовым к выполнению, поток с более низким приоритетом вытесняется планировщиком. По истечению кванта времени текущего потока, ресурс передается самому приоритетному потоку в очереди готовых к выполнению.

В Windows используется 32 уровня приоритета - целое число от 0 до 31:
\begin{itemize}[label*=---]
	\item 0 -- зарезервирован для процесса обнуления страниц;
	\item от 0 до 15 -- динамически изменяющиеся уровни;
	\item от 16 до 31 -- уровни реального времени;
	\item 31 -- наивысший приоритет.
\end{itemize}

Уровни приоритета потоков назначаются в зависимости от двух разных позиций: Windows API и ядра Windows.
Сначала Windows API систематизирует процессы по классу приоритета, который им присваивается при создании:
\begin{itemize}[label*=---]
	\item реального времени (Real-time) - (4);
	\item высокий (High) - (3);
	\item выше обычного (Above Normal) - (6);
	\item обычный (Normal) - (2);
	\item ниже обычного (Below Normal) - (5);
	\item уровень простоя (Idle) - (1).
\end{itemize}

Затем назначается относительный приоритет отдельных потоков внутри этих процессов:
\begin{itemize}[label*=---]
	\item критичный по времени (Time-critical) - (15);
	\item наивысший (Highest) - (2);
	\item выше обычного (Above-normal) - (1);
	\item обычный (Normal) - (0);
	\item ниже обычного (Below-normal) - (–1);
	\item самый низший (Lowest) - (–2);
	\item уровень простоя (Idle) - (–15)
\end{itemize}

В таблице \ref{tab:prioritet} показано соответствие между приоритетами Windows API и ядра системы.

\begin{table}[H]
	\begin{center}
		\caption{Соответствие между приоритетами Windows API и ядра Windows}
		\label{tab:prioritet}
		\resizebox{\textwidth}{!}{
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			\textbf{\thead{Класс приоритета}} & \textbf{Real-time} & \textbf{High} & \textbf{Above} &
			\textbf{Normal} & \textbf{Below Normal} & \textbf{Idle} \\ \hline
			\thead{Time Critical} & 31 & 15 & 15 & 15 & 15 & 15 \\ \hline
			Highest & 26 & 15 & 12 & 10 & 8 & 6 \\ \hline
			\thead{Above Normal} & 25 & 14 & 11 & 9 & 7 & 5 \\ \hline
			Normal & 24 & 13 & 10 & 8 & 6 & 4 \\ \hline
			\thead{Below Normal} & 23 & 12 & 9 & 7 & 5 & 3 \\ \hline
			Lowest & 22 & 11 & 8 & 6 & 4 & 2 \\ \hline
			Idle & 16 & 1 & 1 & 1 & 1 & 1 \\ \hline
		\end{tabular} }
	\end{center}
\end{table}

Планировщик может повысить текущий приоритет потока в динамическом диапазоне (от 1 до 15) вследствие следующих причин:
\begin{itemize}
	\item повышение приоритета владельцем блокировки;
	\item повышение приоритета после завершения ввода/вывода (таблица \ref{tab:input-output});
	\item повышение приоритета вследствие ввода из пользовательского интерфейса;
	\item повышение приоритета вследствие длительного ожидания ресурса исполняющей системы;
	\item повышение вследствие ожидания объекта ядра;
	\item повышение приоритета в случае, когда поток, готовый к выполнению, не был запущен в течение длительного времени;
	\item повышение приоритета проигрывания для мультимедийных приложений (MMCSS). 
\end{itemize}

\begin{table}[H]
	\begin{center}
	\caption{Рекомендуемые значения повышения приоритета}
	\label{tab:input-output}
		\begin{tabular}{|p{100mm}|l|}
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\ \hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\ \hline
			Клавиатура, мышь & 6 \\ \hline
			Звуковая плата & 8 \\ \hline
		\end{tabular}
	\end{center}
\end{table}

\textbf{Диспетчер настройки баланса}

В Windows включен общий механизм ослабления загруженности центрального процессора, который называется \textbf{диспетчером настройки баланса} и является частью системного потока.

Один раз в секунду этот поток сканирует очередь готовых потоков в поиске тех из них, которые находятся в состоянии ожидания около 4 секунд. Если такой поток будет найден, диспетчер настройки баланса повышает его приоритет до 15 единиц и устанавливает квантовую цель эквивалентной тактовой частоте процессора при подсчете 3 квантовых единиц. Как только квант истекает, приоритет потока тут же снижается до обычного базового приоритета. Если поток не был завершен и есть готовый к запуску поток с более высоким уровнем приоритета, поток с пониженным приоритетом возвращается в очередь готовых потоков.

Для минимизации времени своей работы, диспетчер настройки баланса сканирует только 16 готовых потоков. Если на данном уровне приоритета имеется больше потоков, он запоминает то место, на котором остановился, и начинает с него при следующем проходе очереди. Кроме того, он за один проход повысит приоритет только 10 потоков. Если найдет 10 потоков, заслуживающих именно этого повышения, он прекратит сканирование на этом месте и начнет его с этого же места при следующем проходе.

\textbf{MMCSS}

Для того, чтобы мультимедийные потоки могли выполняться с минимальными задержками, драйвер \textit{MMCSS} (\textit{MultiMedia Class Scheduler Service}) временно повышают приоритет потоков до уровня, соответствующего их категориям планирования (таблица \ref{tab:category}). 

Для того, чтобы другие потоки могли получить ресурс, приоритет снижается до уровня, соответствующего категории \textit{Exhausted}.

Категории планирования --- первичный фактор, определяющий приоритет потоков, зарегистрированных в MMCSS:
\begin{table}[H]
	\begin{center}
		\caption{Категории планирования}	
		\label{tab:category}
		\begin{tabular}{|p{40mm}|p{30mm}|p{80mm}|}
			\hline
			\textbf{Категория} & \textbf{Приоритет} & \textbf{Описание} \\
			\hline
			High (Высокая) & 23-26 & Потоки профессионального аудио (Pro
			Audio), запущенные с приоритетом выше, чем у других потоков на системе, за
			исключением критических системных потоков \\
			\hline
			Medium (Средняя) & 16-22 & Потоки, являющиеся частью приложений
			первого плана, например Windows Media Player \\
			\hline
			Low (Низкая) & 8-15 & Все остальные потоки, не являющиеся частью
			предыдущих категорий \\
			\hline
			Exhausted (Исчерпавших потоков) & 1-7 & Потоки, исчерпавшие свою
			долю времени центрального процессора, выполнение которых продолжиться, только
			если не будут готовы к выполнению другие потоки с более высоким уровнем
			приоритета \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\textbf{IRQL}

Для обеспечения поддержки мультизадачности системы, когда исполняется код режима ядра, Windows использует приоритеты прерываний IRQL --- Interrupt Request Level.

Прерывания обслуживаются в порядке их приоритета. При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. Последний повышает IRQL и вызывает
процедуру обслуживания прерывания ISR -- Interrupt Service Routine.

После выполнения ISR диспетчер прерывания понижает IRQL процессора до исходного уровня загружает сохраненные ранее данные о состоянии машины. Прерванный поток возобновляется с той точки, где он был прерван. Когда ядро понижает IRQL, могут начать обрабатываться ранее замаскированные прерывания с более низким приоритетом. Тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.

В ядре IRQL-уровни представлены в виде номеров от 0 до 31, где более высоким номерам соответствуют прерывания с более высоким приоритетом.

Уровни IRQL:
\begin{itemize}[label*=---]
	\item 31 -- наивысший (например, ошибка шины) ;
	\item 30 -- питание;
	\item 29 -- межпроцессорное прерывание;
	\item 28 -- таймер;
	\item 27 -- устройство n;
	\item ..............................;
	\item 3 -- устройство 1;
	\item 2 -- DPC (deferred procedure call)/dispatch);
	\item 1 -- APC (asynchronous procedure call);
	\item 0 -- низший.
\end{itemize}
