\chapter{Аналитический раздел}

\section{Постановка задачи}

В рамках данной работы необходимо разработать загружаемый модуль ядра, позволяющий получать информацию о количестве и времени исполнения системных вызовов open, read и write для заданного процесса. Предоставлять интерфейс для чтения информации в пространстве пользователя. Для реализации цели необходимо решить следующие задачи.

\begin{itemize}
	\item Выбрать способ перехвата системных вызовов.
	\item Выбрать способ взаимодействия пользователя с модулем ядра.
	\item Разработать загружаемый модуль ядра.
	\item Протестировать разработанный модуль.
\end{itemize}

\section{Перехват системных вызовов}

В данный момент существует несколько способов перехвата системных вызовов в ядре Linux:

\begin{itemize}
	\item модификация таблицы системных вызовов;
	\item kernel probes;
	\item function trace.
\end{itemize}

\subsection{Модификация таблицы системных вызовов}

Адреса обработчиков всех системных вызовов хранятся в структуре \texttt{sys\_call\_table}. Соответственно, можно реализовать свою функцию-обработчик системного вызова, и подменить адрес системного вызова в таблице на адрес обработчика~\cite{syscall_table}. 

Данный способ считается устаревшим, и в новых версиях ядра использование данного метода усложнено.

\subsection{Kernel probes}

Kernel probes представляет собой механизм трассировки ядра, позволяющий динамически перехватывать любые функции в ядре для сбора отладочной информации и статистики производительности~\cite{kprobes}. 

При регистрации обработчика функции, Kprobes заменяет первый байт обработчика на прерывание остановки, \texttt{int 3}. Соответственно, механизм не требует каких-либо дополнительных настроек ядра. 

Когда процессор выполняет прерывание, происходит сохранение регистров и передача управление функции-перехватчику, которая собирает отладочную информацию. После выполнения функции-перехватчика, перехватываемый вызов продолжает выполнение с сохраненными значениями регистров.

Кроме перехвата начала выполнения функции, существует механизм return probes, позволяющий выполнять дополнительные фрагменты кода при возврате из перехватываемой функции. В этом случае, при вызове пред-обработчика функции происходит замена инструкции возврата на код обработчика return probe.

Наличие механизмов перехвата как в начале выполнения, так и в конце выполнения системного вызова, позволяет замерять время исполнения.

\subsection{Function trace}

ftrace~---~это фреймворк для трассировки ядра на уровне функций~\cite{ftrace}. Изначально, вместо вызовов функций трассировки находится заглушка, которая заменяется на отладочные функции при включений трассировки~\cite{ftrace_design}.

Function trace требует использования дополнительных настроек ядра. Кроме того, интерфейс ftrace не предполагает вызовов обработчика после выполнения функции, так что замер времени выполнения функции при его использовании, необходимо осуществлять с помощью замены пути выполнения системного вызова: обработчик должен перенаправлять выполнение на отладочную реализацию системного вызова.


\subsection{Выбор способа перехвата системных вызовов}

В результате обзора различных способов перехвата системных вызовов был выбран kernel probes, так как он не требует дополнительных настроек ядра и позволяет решать поставленную задачу.

\section{Взаимодействие пользователя с модулем ядра}

Для взаимодействия пользователя с модулем ядра выбрана файловая система /proc, так как она позволяет решить поставленную задачу, и предназначена для вывода пользователю информации о системе и работе ядра~\cite{procfs}.

Для созданного в файловой системе \texttt{/proc} файла можно определить функции чтения и записи с помощью структуры \texttt{proc\_ops}, часть которой приведена в листинге \ref{lst:proc_ops}.

\begin{lstlisting}[language=C, label=lst:proc_ops, caption={Структура \texttt{proc\_ops}}]
struct proc_ops {
	...
	ssize_t	(*proc_read)(struct file *, char __user *, size_t, loff_t *);
	ssize_t	(*proc_write)(struct file *, const char __user *, size_t, loff_t *);
	...
} __randomize_layout;
\end{lstlisting}

\begin{itemize}
	\item \texttt{proc\_read}~---~указатель на функцию чтения из файла;
	\item \texttt{proc\_write}~---~указатель на функцию записи в файл.
\end{itemize}

Создать файл в файловой системе \texttt{/proc} можно с помощью функции \texttt{proc\_create}, синопсис которой приведен в листинге \ref{lst:proc_create}.

\begin{lstlisting}[language=C, label=lst:proc_create, caption={Синопсис функции \texttt{proc\_create}}]
struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct proc_ops *proc_ops);
\end{lstlisting}

\begin{itemize}
	\item \texttt{name}~---~имя файла;
	\item \texttt{mode}~---~права доступа к файлу;
	\item \texttt{parent}~---~родительский каталог;
	\item \texttt{proc\_ops}~---~структура \texttt{proc\_ops}, определяющая файловые операции.
\end{itemize}

\section{Перехват системных вызовов с помощью Kernel return probes}

Для определения перехватываемого системного вызова используется структура \texttt{kprobe}, название функции указывается в поле \texttt{symbol\_name}. Объявление структуры \texttt{kprobe} представлено в листинге \ref{lst:kprobe}.

\begin{lstlisting}[language=C, label=lst:kprobe, caption={Структура \texttt{kprobe}}]
struct kprobe {
	...
	/* Allow user to indicate symbol name of the probe point */
	const char *symbol_name;
	...
};
\end{lstlisting}

Для установки функций-перехватчиков используется структура \texttt{kretprobe}, объявление которой представлено в листинге \ref{lst:kretprobe}.

\begin{lstlisting}[language=C, label=lst:kretprobe, caption={Структура \texttt{kretprobe}}]
typedef int (*kretprobe_handler_t) (struct kretprobe_instance *,
				    struct pt_regs *);

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
};
\end{lstlisting}

\begin{itemize}
	\item \texttt{kp}~---~структура \texttt{kprobe}, в которой задается имя перехватываемой функции;
	\item \texttt{entry\_handler}~---~указатель на обработчик, вызываемый при входе в перехватываемую функцию;
	\item \texttt{handler}~---~указатель на обработчик, вызываемый при возврате из перехватываемой функции;
	\item \texttt{maxactive}~---~максимальное количество функций, которые можно обрабатывать одновременно.
\end{itemize}

\section*{Вывод}

В результате аналитической части были рассмотрены способы перехвата системных вызовов: модификация таблицы системных вызовов, kernel probes и function trace. На основе постановки задачи был выбран kernel probes, как наиболее подходящий. Были рассмотрены структуры и функции, необходимые для установки обработчиков перед и после выполнения системного вызова. Определен способ взаимодействия с модулем из пространства пользователя~---~файловая система \texttt{/proc}.
